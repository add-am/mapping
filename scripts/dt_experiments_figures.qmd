---
title: "Simplified Technical Report Figures"
subtitle: "A Healthy Waters Partnership Analysis"
description: "This script explores the possibility of embedding and exporting images from within the R engine, and more specifically, from within the Quarto framework. The outputs of this script are currently used for demonstration purposes."
author: "Adam Shand"
params:
  project_crs: "EPSG:7844"
---

# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(tidyverse, glue, here, magick)

```


Then we will need to set up a data folder and a save folder, to store the data needed for the script, and the outputs created by the script.

```{r}
#| label: Initial setup 2

#create a file path to help with saving things
save_path <- here("outputs/dt_experiments_figures/")

#This script needs no data inputs

#bring the path to life
dir.create(save_path)

```

# Figures

As mentioned above, this script is about exploring the options available for figures. To test these options we need figures. We will use the iris dataset that is shipped with R for this.

```{r}
#| label: Create figures

#create an example figure
example_figure <- ggplot(iris, aes(x = Petal.Length, y = Petal.Width, 
                                   group = Species, colour = Species)) +
  geom_point()

```

## Simple Export

The most generic option for handling figures from R is to export the image as a png. The image can then be opened by another software and manually placed into the report document.

```{r}
#| label: Export Image

ggsave(glue("{save_path}/basic_export.png"), example_figure)

```

## Inline Printing

### Single Image

The second option is to print the figure inline, i.e. call the image within the code.

```{r}
#| label: Print image inline
#| output: true

example_figure

```

Printing an image inline is a good option when the script is an rmarkdown or quarto document, as the script is rendered to a html or word format.

### Multiple Images

This also works just as well with large quantities of images, a loop of 3 is demonstrated below, but this could just as easily be a loop of 100's.

```{r}
#| label: print in loop

#3 random colours to make each graph a bit different from one another
random_colours <- c("#e08aaf","#52c95f","#a742ba")

count <- 1

for (i in random_colours){#loop over each colour
  
  temp_fig <- ggplot(iris, aes(x = Petal.Length, y = Petal.Width)) +
    geom_point(color = i)
  
  print(temp_fig)
  
  #assign a name so we can keep it in the global environment if needed
  assign(glue("fig_{count}"), temp_fig)

  count <- count + 1
  
}

```

## Export - Import - Print

However things can get a bit more complicated than this. Imagine if there are multiple separate scripts each producing figures, or if the script that produces the figures also contains alot of superfluous code that we don't need to show in the file rendered output. To handle a more realistic scenario such as this one the current method is to go with the simple export, as shown further up, and then manually putting each figure into a document.

Alternatively we can combine the two methods shown earlier, with the only requirement that all the target images are placed into the same folder.

### Export Multiple Images

First we need to create multiple images to use.

```{r}
#| label: export multiple images

for (i in 1:3){
  
  ggsave(glue("{save_path}/fig_{i}.png"), get(glue("fig_{i}")))

}


```

### Import and Print Multiple Images

Then it is easy to read in all files with a specific extension in a specific folder and print them inline one by one. The trick here is to manually build the path to each image.

```{r}
#| label: import and print multiple images 1
#| output: true

files_to_print <- list.files(glue("{save_path}/"))

knitr::include_graphics(glue("/outputs/{basename(save_path)}/{files_to_print}"), error = F, rel_path = F)

```

### Invisible Print

The coup de grÃ¢ce is producing a completely raw document with only the images so the resulting document can simply be appended to the main working document. Although you can't see it, a code chunk was written to produce the below images.

```{r}
#| label: import and print multiple images 2
#| output: true

knitr::include_graphics(glue("/outputs/{basename(save_path)}/{files_to_print}"), error = F, rel_path = F)

```

By the way, you can also add figure captions with numbers, however the numbers are not dynamic so this isn't super relevant:

```{r}
#| label: fig-charts
#| fig-cap: "Example Caption"
#| output: true

knitr::include_graphics(glue("/outputs/{basename(save_path)}/{files_to_print[1]}"), error = F, rel_path = F)

```
