---
title: "Northern Three Spatial Analyses (Digital Elevation Models - Healthy Waters Partnership Region Outline)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`" 
format: html
params:
  dataset_resolution: 30
  project_crs: "EPSG:7844"
---

::: {.callout-tip}
## R Version
For R session info at the time of rendering this script see @sec-sessioninfo.
:::

# Introduction

This is script uses the Digital Elevation Model workflow to produce a region outline map for the Healthy Waters Partnership. For a guide on general usage of the functions used in this process refer to `n3_dem_example-workflow.qmd` or the rendered version of the script.

# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(tidyverse, glue, here, janitor, sf, tmap, raster, terra, rayshader, readxl)

```


We also need to set up key variables for the script such as where we are going to save the outputs, and what coordinate reference system (crs) we are going to be using. Note that the crs is first established under 'params' at the start of the script.

```{r}
#| label: establish global controls and settings
#| output: false

#set project variables
proj_crs <- params$project_crs

#create a file path to help with saving things
save_path <- here("outputs/n3_dem_hwp-region/")

#bring that path to life
dir.create(save_path)

#turn of spherical geometry
sf_use_s2(FALSE)

```

# Load Data

Now the script is set up we need to load in all of the required datasets. This will be broken into two segments:
- Spatial data specific to the N3 region - such as the region, basin, sub basin and watercourses
- Digital Elevation Model (DEM) data used to create the 3D model.

## Spatial Data

Spatial data for the northern three regions should be readily available in the repo, the dataset is created by the n3_region-builder.qmd script in the repo that should be the first script run for new users. If the dataset is not available refer back to the README document in the GitHub repo. The other parts of spatial data here should go off without a hitch if the region-builder script has been run.

```{r}
#| label: load N3 spatial data

#read in the northern three spatial files
n3_region <- st_read(here("data/n3_prep_region-builder/n3_region.gpkg"))

#filter for only what we need (which is exclusively the land components of the dt region)
dt_land <- n3_region |> 
  filter(basin_or_zone %in% c("Black", "Ross")) |> 
  st_union() |> st_as_sf()

#filter for the complete opposite of this, but also only for the land (used as a shader in the map)
not_dt_land <- n3_region |> 
  filter(!basin_or_zone %in% c("Black", "Ross"),
         environment != "Marine")

#read in the northern three watercourses and restrict to what we want
dt_watercourse <- st_read(here("data/n3_prep_region-builder/n3_watercourse.gpkg")) |> 
  filter(region == "Dry Tropics",
         !stream_order %in% c(0, 1))

#split into just the linestring
dt_water_lines <- dt_watercourse |> 
  st_collection_extract("LINESTRING")

#split into just the area
dt_water_areas <- dt_watercourse |> 
  st_collection_extract("POLYGON")

```

### Points of Interest

We will also deviate slightly here to get all the points of interest. This was an addition requested by the ISP.

```{r}
#| label: get points of interest

#load freshwater, estuarine, and inshore coords
fw <- read_excel(here("data/dt_water-quality_freshwater/raw/dt_wq_freshwater_metadata.xlsx"),
                 sheet = "Current_Sites") |> 
  select(Environment, Code, Long, Lat) |> 
  st_as_sf(coords = c("Long", "Lat"), crs = proj_crs)
est <- read_excel(here("data/dt_water-quality_estuarine/raw/dt_wq_estuarine_metadata.xlsx"),
                 sheet = "Current_Sites") |> 
  select(Environment, Code, Long, Lat) |> 
  st_as_sf(coords = c("Long", "Lat"), crs = proj_crs)
insh <- read_excel(here("data/dt_water-quality_inshore/raw/dt_wq_inshore_metadata.xlsx"),
                 sheet = "Current_Sites") |> 
  select(Environment, Code, Long, Lat) |> 
  st_as_sf(coords = c("Long", "Lat"), crs = proj_crs)

#combine the three together
dt_wq_points <- rbind(fw, est, insh)

#clean up
rm(fw, est, insh)

```


## DEM data

We can use the custom built `dem_data_pre_processing.R` function for this step. Refer to the n3_dem_example-workflow script for more information.

```{r}
#| label: load and cut down DEM datasets

#set area of interest
dt_area <- st_as_sfc(st_bbox(dt_land)) 

#then converting to a SpatVector
dt_area <- vect(dt_area)

#read in the function
source(here("functions/dem_data_pre_processing.R"))

#use the function, refer to text chuck above for guidance.
dem_data_pre_processing(dt_area, name = "dry_tropics", save = save_path, resolution = 30, reload = T)

```

# Visualise Data

We can now begin to visualise our dem.

## Create Base Elements

We can then convert the SpatRaster into the base components needed for a 3D model. A function called `dem_base_map()` has been created to help in this process, and will handle the base map elements creation. For a detailed look at the function refer to the generic dem_workflow script.

```{r}
#| label: create base map elements using function

#read in the function
source(here("functions/dem_base_map.R"))

#use the function, try not to use spaces in the name
dem_base_map(dry_tropics_dem, sea_level = 0, z_scale = 15, name = "dry_tropics", save = save_path, resolution = 30, reload = T)

```

This function shouldn't need to be edited unless it breaks. If so, the best way to learn about the function is to go and read above the underlying R packages that the function uses [here](https://www.tylermw.com/).

## Create Overlays

Now we can use the array and matrix created above, along with some variations of the focus area, to create additional overlays that make our map pretty. This includes adding highlights, lowlights, rivers, and points of interest.

```{r}
#| label: create overlays

#get the extent using the original SpatVector that defines the area of interest - this tells the overlay where to put itself
dt_extent <- ext(dt_area)

#create some overlays
dt_overlay_1 <- generate_polygon_overlay(dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = "transparent",
                                         linecolor = "black", linewidth = "8")
dt_overlay_2 <- generate_polygon_overlay(dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = "transparent",
                                         linecolor = "white", linewidth = "7")
dt_overlay_3 <- generate_polygon_overlay(not_dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = "black",
                                         linecolor = "black", linewidth = "0")
dt_overlay_4 <- generate_line_overlay(dt_water_lines, extent = dt_extent,
                                      dry_tropics_matrix, color = "dodgerblue",
                                      linewidth = "5")
dt_overlay_5 <- generate_polygon_overlay(dt_water_areas, extent = dt_extent,
                                         dry_tropics_matrix, palette = "dodgerblue",
                                         linecolor = "dodgerblue", linewidth = "0")
dt_overlay_6 <- generate_point_overlay(dt_wq_points, extent = dt_extent,
                                       dry_tropics_matrix, color = "black",
                                       size = 30)
dt_overlay_7 <- generate_point_overlay(dt_wq_points, extent = dt_extent,
                                       dry_tropics_matrix, color = "orange",
                                       size = 26)


```

# Create Map

We can the create the map by combing the overlays we just created with the basemap produced earlier.

```{r}
#| label: create map

#add the overlays to the base array
dry_tropics_array_1 <- dry_tropics_array |> 
  add_overlay(dt_overlay_1) |>
  add_overlay(dt_overlay_2) |> 
  add_overlay(dt_overlay_3, alphalayer = 0.7) |> 
  add_overlay(dt_overlay_4) |> 
  add_overlay(dt_overlay_5) |> 
  add_overlay(dt_overlay_6) |> 
  add_overlay(dt_overlay_7)

#re run the 3d map
plot_3d(dry_tropics_array_1, dry_tropics_matrix, windowsize = c(50, 50, 1920, 1080), zscale = 10,
        theta = 0, phi = 36.77, fov = 20, zoom = 0.61, soliddepth = -500)

```

```{r}
#| label: close the rgl window 1

#close the rgl window
rgl::close3d()

```

# Save Map

Once you are happy with the map, it is time to save. This is a fairly standard procedure and uses the `render_snapshot()` function. Note that the rgl window has to be open to save (and that labels have to be added to the rgl window before saving - they cant be saved to the underlying array and matrix).

```{r}
#| label: save the map

#use render camera to get angles
#render_camera()

#re run the 3d map
plot_3d(dry_tropics_array_1, dry_tropics_matrix, windowsize = c(50, 50, 1920, 1080), zscale = 40,
        theta = 0, phi = 36.77, fov = 0, zoom = 0.61, soliddepth = -500)

#save the map
render_snapshot(glue("{save_path}/dry_tropics_30m_map"))

#close the rgl window
rgl::close3d()

```

# Session Info {#sec-sessioninfo}

Below is the session info at the time of rendering this script. Of greatest importance is to note the R version, and the "other attached packages" as these are the most significant drivers of success/failure. It is also good to check the "attached base packages" and "loaded via a namespace" packages as well. To check your session info use `sessionInfo()`.

```{r}
#| label: show session info

sessionInfo()

```
