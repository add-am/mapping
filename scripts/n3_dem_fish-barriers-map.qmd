---
title: "Fish Barriers Digital Elevation Model"
subtitle: "A Healthy Waters Partnership Analysis"
description: "This script creates a digital elevation model (DEM) for the fish barriers dataset."
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`" 
format: html
params:
  dataset_resolution: 30
  project_crs: "EPSG:7844"
---

# Introduction

This is script uses the Digital Elevation Model workflow to produce a map for the fish barrier identification workflow. This map will show the elevation of the area, with outlines for each sub basin in the HWP region, watercourses depicted, and a legend per sub basin.

# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(raster, tidyverse, glue, here, janitor, sf, tmap, terra, rayshader, readxl, Polychrome)

```

We also need to set up key variables for the script such as where we are going to save the outputs, and what coordinate reference system (crs) we are going to be using. Note that the crs is first established under 'params' at the start of the script.

```{r}
#| label: establish global controls and settings
#| output: false

#set project variables
proj_crs <- params$project_crs

#create a file path to help with saving things
save_path <- here("outputs/n3_dem_fish-barriers-map/")

#bring that path to life
dir.create(save_path)

#turn of spherical geometry
sf_use_s2(FALSE)

#read in the custom function to clean column names into our specific style
source("../functions/name_cleaning.R")

```

# Load Data

Now the script is set up we need to load in all of the required datasets. This will be broken into two segments:
- Spatial data specific to the N3 region - such as the region, basin, sub basin and watercourses
- Digital Elevation Model (DEM) data used to create the 3D model.

## Spatial Data

Spatial data for the northern three regions should be readily available in the repo, the dataset is created by the n3_region-builder.qmd script in the repo that should be the first script run for new users. If the dataset is not available refer back to the README document in the GitHub repo. The other parts of spatial data here should go off without a hitch if the region-builder script has been run.

```{r}
#| label: load N3 spatial data

#read in the northern three spatial files
n3_region <- st_read(here("data/n3_prep_region-builder/n3_region.gpkg")) |> 
  name_cleaning()

#filter for only what we need (which is exclusively the land components of the dt region)
dt_land <- n3_region |> 
  filter(BasinOrZone %in% c("Black", "Ross")) |> 
  select(!Environment) |> 
  group_by(SubBasinOrSubZone) |> 
  mutate(geom = st_union(geom)) |> 
  unique()

#filter for the complete opposite of this, but also only for the land (used as a shader in the map)
not_dt_land <- n3_region |> 
  filter(!BasinOrZone %in% c("Black", "Ross"),
         Environment != "Marine")

#read in the northern three watercourses and restrict to what we want
dt_watercourse <- st_read(here("data/n3_prep_watercourse-builder/n3_watercourse.gpkg")) |> 
  name_cleaning() |> 
  filter(Region == "Dry Tropics",
         !StreamOrder %in% c(0, 1))

#split into just the linestring
dt_water_lines <- dt_watercourse |> 
  st_collection_extract("LINESTRING")

#split into just the area
dt_water_areas <- dt_watercourse |> 
  st_collection_extract("POLYGON")

```

## DEM data

We can use the custom built `dem_data_pre_processing.R` function for this step. Refer to the n3_dem_example-workflow script for more information.

```{r}
#| label: load and cut down DEM datasets

#set area of interest
dt_area <- st_as_sfc(st_bbox(dt_land)) 

#then converting to a SpatVector
dt_area <- vect(dt_area)

#read in the function
source(here("functions/dem_data_pre_processing.R"))

#use the function, refer to text chuck above for guidance.
dem_data_pre_processing(dt_area, name = "dry_tropics", save = save_path, resolution = 30, reload = T)

```

# Visualise Data

We can now begin to visualise our dem.

## Create Base Elements

We can then convert the SpatRaster into the base components needed for a 3D model. A function called `dem_base_map()` has been created to help in this process, and will handle the base map elements creation. For a detailed look at the function refer to the generic dem_workflow script.

```{r}
#| label: create base map elements using function

#read in the function
source(here("functions/dem_base_map.R"))

#use the function, try not to use spaces in the name
dem_base_map(dry_tropics_dem, sea_level = 0, z_scale = 15, name = "dry_tropics", save = save_path, resolution = 30, reload = T)

```

This function shouldn't need to be edited unless it breaks. If so, the best way to learn about the function is to go and read above the underlying R packages that the function uses [here](https://www.tylermw.com/).

## Create Overlays

Now we can use the array and matrix created above, along with some variations of the focus area, to create additional overlays that make our map pretty. This includes adding highlights, lowlights, rivers, and points of interest.

```{r}
#| label: create overlays

#get the extent using the original SpatVector that defines the area of interest - this tells the overlay where to put itself
dt_extent <- ext(dt_area)

#create some overlays
dt_overlay_1 <- generate_polygon_overlay(dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = "transparent",
                                         linecolor = "black", linewidth = "8")
dt_overlay_2 <- generate_polygon_overlay(dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = "transparent",
                                         linecolor = "white", linewidth = "7")
dt_overlay_3 <- generate_polygon_overlay(not_dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = "black",
                                         linecolor = "black", linewidth = "0")
dt_overlay_4 <- generate_line_overlay(dt_water_lines, extent = dt_extent,
                                      dry_tropics_matrix, color = "dodgerblue",
                                      linewidth = "5")
dt_overlay_5 <- generate_polygon_overlay(dt_water_areas, extent = dt_extent,
                                         dry_tropics_matrix, palette = "dodgerblue",
                                         linecolor = "dodgerblue", linewidth = "0")

#create a palette for each of the sub zones and match names to target column
custom_pallette <- setNames(glasbey.colors(length(dt_land$SubBasinOrSubZone)), dt_land$SubBasinOrSubZone)

#create the last overlay
dt_overlay_6 <- generate_polygon_overlay(dt_land, extent = dt_extent,
                                         dry_tropics_matrix, palette = custom_pallette,
                                         data_column_fill = "SubBasinOrSubZone")

```

# Create Map

We can the create the map by combing the overlays we just created with the basemap produced earlier.

```{r}
#| label: create map

#add the overlays to the base array
dry_tropics_array_1 <- dry_tropics_array |> 
  add_overlay(dt_overlay_1) |>
  add_overlay(dt_overlay_2) |> 
  add_overlay(dt_overlay_3, alphalayer = 0.7) |> 
  add_overlay(dt_overlay_4) |> 
  add_overlay(dt_overlay_5) |> 
  add_overlay(dt_overlay_6, alphalayer = 0.5)

#re run the 3d map
plot_3d(dry_tropics_array_1, dry_tropics_matrix, windowsize = c(50, 50, 1920, 1080), zscale = 10,
        theta = 0, phi = 36.77, fov = 20, zoom = 0.61, soliddepth = -500)

```

```{r}
#| label: close the rgl window 1

#close the rgl window
rgl::close3d()

```

# Save Map

Once you are happy with the map, it is time to save. This is a fairly standard procedure and uses the `render_snapshot()` function. Note that the rgl window has to be open to save (and that labels have to be added to the rgl window before saving - they cant be saved to the underlying array and matrix).

```{r}
#| label: save the map

#use render camera to get angles
#render_camera()

#re run the 3d map
plot_3d(dry_tropics_array_1, dry_tropics_matrix, windowsize = c(50, 50, 1920, 1080), zscale = 10,
        theta = 0, phi = 36.77, fov = 20, zoom = 0.61, soliddepth = -500)

#save the map
render_snapshot(glue("{save_path}/dry_tropics_30m_map"))

#close the rgl window
rgl::close3d()

```

After saving the map we also need to save the sub basin color information so a legend can be created in post.

```{r}
#| label: save palette information

#currently this contains duplicates so we will remove these
custom_pallette <- data.frame(names(custom_pallette), unique(custom_pallette))

#then write to a csv
write_csv(custom_pallette, glue("{save_path}/colour_palette.csv"))

```
