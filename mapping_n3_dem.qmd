---
title: "Northern Three Mapping (Digital Elevation Models)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`" 
format: html
params:
  dataset_resolution: 100
  project_crs: "EPSG:7844"
---

A script to create "easily" customisable 3D maps of the Northern Three region using 
digital elevation model (DEM) data.

# Initial Setup

The setup for this script can be difficult and may require additional troubleshooting 
as several of the dependencies are still in alpha development and change frequently.

First install the remotes package if not already installed:

```{r}
#| label: get remotes package
#| output: false

#create list of packages to check
package_list <- c("remotes")

#check if packages are installed
new_packages <- package_list[!(package_list %in% installed.packages()[,"Package"])]

#if length is anything but zero, install
if(length(new_packages)) install.packages(new_packages)

#cleanup
rm(package_list, new_packages)


```

Then using the remotes package install the alpha packages using the install_github() 
function and following the prompts. Alpha packages include:

-   rayshader
-   rayrender
-   rayimage

```{r}
#| label: install ray... packages
#| output: false

#remotes::install_github("tylermorganwall/rayvertex")
#remotes::install_github("tylermorganwall/rayshader")
#remotes::install_github("tylermorganwall/rayrender")
#remotes::install_github("tylermorganwall/rayimage")

```

Once these packages are installed and up to date the remaining packages can be installed 
and loaded the normal way.

```{r}
#| label: install and load remaining packages
#| output: false

#mapping
library(rayshader)
library(raster)
library(sf)
library(osmdata)
library(ggplot2)

#extra utils
library(glue)
library(tmap)
library(tidyverse)
#library(av) #Y
#library(gifski) #Y
#library(leaflet) #Y

```

# Global Controls

As always, we then need to assign the global controls. Our project coordinate 
reference system (CRS) is set to `r params$project_crs`. Two DEM data sets can 
be used, either the 30m data or 100m data. Thisrefers to the cell size of the data 
(smaller is higher resolution). This script is currently using the 
`r params$dataset_resolution` data.

```{r}
#| label: establish global controls and settings
#| output: false

#set project variables
proj_crs <- params$project_crs
data_set <- params$dataset_resolution

#format the date for the path below and to be used as a variable in naming later
date <- format(Sys.time(), "%Y-%m-%d")

#create a file path to help with saving things
save_path <- glue("output/{date}_n3-dem_resolution-{data_set}m/")

#bring that path to life
dir.create(save_path)

#initilize with static mapping
tmap_mode("plot")

#set global theme for plots
theme_set(theme_bw())

#turn of spherical geometry
sf_use_s2(FALSE)

```

# Data Source

Load in the DEM data. If this is the first time running the analysis please
refer to the .README for this repo for a guide on downloading the data.


```{r}
#| label: read in data

#read the DEM based on dataset resolution
gbr <- raster::raster(glue("data/elevation/gbr_{data_set}m_2020.tif"))

```

# Basin Selection

Load in the shapefiles required for analysis. Should you need to re-download the
files please refer to the .README for this repo.

```{r}
#| label: Read and Prep Basin Shapefiles
#| output: false
#| fig-cap: Northern three basins

#read the drainage basins and drainage basin sub areas
basins <- st_read(dsn = "data/shapefiles/Drainage_basins.shp")
sub_basins <- st_read(dsn = "data/shapefiles/Drainage_basin_sub_areas.shp")

#update crs
basins <- st_transform(basins, proj_crs)
sub_basins <- st_transform(sub_basins, proj_crs)

#select northern three basins based on list of names
n3_basins <- basins %>% 
  filter(BASIN_NAME %in% c("Ross", "Black", "Don", "Proserpine", "O'Connell", 
                           "Pioneer", "Plane", "Daintree", "Mossman", "Barron", 
                           "Johnstone", "Tully", "Murray", "Herbert"))

#wet tropics split mulgrave-russell into two separate sub basins.
#get Russell and Mulgrave River from sub_basins
temp <- sub_basins %>% 
  filter(SUB_NAME %in% c("Russell River", "Mulgrave River")) %>% 
  mutate(SUB_NAME = case_when(SUB_NAME == "Russell River" ~ "Russell",
                              SUB_NAME == "Mulgrave River" ~ "Mulgrave")) %>% 
  rename(BASIN_NAME = SUB_NAME, BASIN_NUMB = SUB_NUMBER)

#add the two basins onto main
n3_basins <- rbind(n3_basins, temp)

#clean up
rm(temp, basins, sub_basins)

#remove unwanted vars and add regional context
n3_basins <- n3_basins %>% 
  select(BASIN_NAME) %>% 
  rename(basin = BASIN_NAME) %>% 
  mutate(region = case_when(
    str_detect(basin, "Ross|Black") ~ "Dry Tropics",
    str_detect(basin, "Dain|Moss|Barr|John|Tull|Murr|Herb|Mulg|Russ") ~ "Wet Tropics",
    str_detect(basin, "Don|Proser|O'|Pio|Plane") ~ "Mackay Whitsunday Isaac"
    ), .after = basin)

#plot to show
tm_shape(n3_basins) +
  tm_polygons() +
  tm_facets(by = "basin")

```

# Creating Base Maps

The DEM dataset covers the entire span of the GBR and coastline of Australia. 
Creating a single map of the entire area would crash a standard computer so this 
section covers selecting a specific region and creating the base map. Additional 
customization of the map then follow.

A function has been created to handle the base map creation. **Note that creating 
3D maps will take a significant amount of time, even for smaller maps at lower 
resolutions - please give the script time to run.** Therefore, when the function
is run, a 3D matrix and 3D array are also saved. These can be loaded back in to
skip the high intensity processing step if needed by using the "preload = T" option
in the function.

```{r}
#| label: Create base map
#| include: false

#load the function to create the base map
source("functions/n3_dem_base_map.R")

#create a table of the variables created for easy tracking
key_tbl <- tibble()

#get unique target names
names <- unique(n3_basins$region)

for (i in 1:length(names)){
  
  #mutate name for save file
  names1 <- gsub(" ", "-", names[i])
  
  #mutate again for key table (look inside the function below)
  names2 <- paste((str_extract_all(names1, "[:upper:]"))[[1]], collapse = "")
  
  #create a shapefile that contains only the region of interest. Combine all polygons
  target <- n3_basins %>% 
    filter(str_detect(region, names[i])) %>% 
    st_union(by_feature = F) %>% st_combine() %>%
    nngeo::st_remove_holes() %>% 
    st_sf() %>% 
    mutate(region = names1, .before = geometry)
  
  #run the function using the DEM data and the shapefile, will return a var called 
  #base_map, and a height matrix called dem_matrix. It will also save the base_map
  #as an array, matrix and image. The array and matrix can be loaded back in anytime
  #to avoid the high intensity processing step. A table of town names within the 
  #region is also created. Zscale = 10 for 30m data, and 30 for 100m data
  n3_dem_base_map(dem = gbr, region = target, zscale = 30, sealevel = -30, highlight = T, rivers = T, preload = T)
  
  #track variables
  key_tbl <- rbind(key_tbl, global_list)
  
}

#rename tbl columns
key_tbl <- key_tbl %>% 
  rename("base_map" = 1, "dem" = 2, "town_names" = 3, "location_extent" = 4)



```

The 2d base map looks like this:

::: {#fig-2D layout-ncol=3}

![2D Map DT](images/DT 2D example.png)

![2D Map DT](images/WT 2D example.png)

![2D Map DT](images/MWI 2D example.png)

2D Maps
:::

The list of available towns that can be added to the 3D model, like this:

``` {r}

head(town_names_DT)

```
The key table that summarises what variables have been created and can now be 
used for the following steps, like this:

``` {r}

head(key_tbl)

```
And the 3D base maps, like this: 

::: {#fig-3D layout-ncol=3}

![3D Map DT](images/DT 3D example.png)

![3D Map WT](images/WT 3D example.png)

![3D Map MWI](images/MWI 3D example.png)

3D Maps
:::


## Customizing the Base Map

Using the function above, customization of the base map can be done. For instance:

-   Sea level can be changed to any height (in meters)
-   Basin outlines and highlights can be toggled on and off
-   Major rivers (top 50 by length) can be toggled on and off

Additional customization can also be done after the function has run. For instance:

-   City/Town/POI labels can be added.
-   Camera position can be changed.
-   Image ratio can be adjusted.

Please note that the initially saved 3D version may not be in the correct orientation, 
and image ratio for the specific location. These must be adjusted post creation 
as they vary on a case by case basis.

The code chunk below runs through these customisations. Make sure to refer to the
key_tbl to see what variables are available, what their names are, and what group
they belong to.

```{r}
#| label: Customizing the 3D map further

#pull up the rgl window again
plot_3d(base_map_WT, dem_matrix_WT, zscale = 30, soliddepth = min(dem_matrix_WT)-200,
        water = F, background = "white", shadowcolor = "grey50", 
        shadowdepth = min(dem_matrix_WT)-400, theta = 90, phi = 35, zoom = 0.47, fov = 16, 
        windowsize = c(50, 50, 1920, 1080))

#get the camera angle
render_camera()

#DT: 180, 35, 0.6, 16
#WT: 90, 35, 0.47, 16
#MWI: 90, 32, 0.4, 28

#use this to clear label
render_label(clear_previous = TRUE)

#render labels from the town_names df. With the [] system, the row index is the 
#first number. Lat is always 3, long is always 2, and name is always 1. 
render_label(dem_matrix_WT, lat = town_names_WT[51,3], long = town_names_WT[51,2], 
             extent = location_extent_WT, altitude=9000, zscale=10, 
             linewidth = 3, linecolor = "white", textsize = 1.5, text = town_names_WT[51,1])
#labels come in sets of 2 to create a black outline on the markers
render_label(dem_matrix_WT, lat = town_names_WT[51,3], long = town_names_WT[51,2], 
             extent = location_extent_WT, altitude=9000, zscale=10, 
             text = town_names_WT[51,1], textalpha = 0, linewidth = 6)

render_label(dem_matrix_MWI, lat = town_names_MWI[311,3], long = town_names_MWI[311,2], 
             extent = location_extent_MWI, altitude=12000, zscale=10, 
             linewidth = 3, linecolor = "white", textsize = 1.5, text = town_names_MWI[311,1])
#labels come in sets of 2 to create a black outline on the markers
render_label(dem_matrix_MWI, lat = town_names_MWI[311,3], long = town_names_MWI[311,2], 
             extent = location_extent_MWI, altitude=12000, zscale=10, 
             text = town_names_MWI[311,1], textalpha = 0, linewidth = 6)


```

Once any additional features have been added, the camera can then be positioned 
as required and the map saved as an image.

``` {r}
#| label: save final image

#Basic snapshot render of the current RGL view.
render_snapshot(filename = glue("{save_path}Wet-Tropics_3D-final-map_sea-level--30m"))

#close the rgl window
rgl::close3d()


```
