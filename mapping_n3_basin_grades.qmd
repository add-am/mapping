---
title: "Northern Three Mapping (Basin Grades)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`" 
format: html
params:
  project_crs: "EPSG:7844"
---

A script to programmatically create basins colored by grade.

# Global Controls

Before diving in, we must establish some global variables that provide critical control over the output, and as usual, install/load packages

```{r}
#| label: load packages
#| output: false
#| echo: false

#graphing and mapping
library(RColorBrewer) #colour palettes, and create custom palettes
library(sf) #read and manipulate simple features
library(tmap) #map data
library(osmdata) #online data repo from open street map

#general setup and data manipulation
library(glue) #easier to create strings, particularly those contains variables
library(lubridate) #time manipulation
library(terra) #spatial raster manipulation
library(tidyverse) #contains multiple useful packages (https://www.tidyverse.org/packages/)
library(stringr) #additional help on string manipulation

```

```{r}
#| label: global vars and initial setup
#| output: false

#set project variables: crs factor and current_fyear
proj_crs <- params$project_crs

#format the date for the path below and to be used as a variable in naming later
date <- format(Sys.time(), "%Y-%m-%d")

#create a file path to help with saving things
save_path <- glue("output/{date}_n3-basin-grader/")

#bring that path to life
dir.create(save_path)

#initilize with static mapping
tmap_mode("plot")

#turn off spherical geometry
sf_use_s2(F)

```

# Data Source

This script uses shapefiles created in previous scripts. Refer to the .README for this repo if the data has not been created. City names within the region are also queried here.

``` {r}
#| label: read in shapefiles
#| output: false

#get the DT shapefile
dt_region <- st_read(dsn = "data/shapefiles/", layer = "Dry-Tropics-Basins-Detailed")

#update crs
dt_region <- st_transform(dt_region, proj_crs)

#get qld shapefile
qld <- get(data("gbr_feat", package = "gisaimsr")) |> 
  filter(FEAT_NAME %in% c("Mainland", "Island")) |> 
  st_transform(proj_crs)

#create a bounding box based on the region
bbox <- st_bbox(dt_region)
osm_bbox = c(bbox[1],bbox[2], bbox[3],bbox[4])
  
#download labels in region
places <- opq(osm_bbox, timeout = 100) |> 
  add_osm_feature("place") |> osmdata_sf()
  
#transform data and filter for only point data
places <- st_transform(places$osm_points, crs = crs(proj_crs))
  
#filter for cities
cities <- places |> select(name, place, geometry) |> filter(place == "city")

#clean up
rm(places)

```

# Creating the Map

This is a work in progress and is on standby currently. A rough example map is producable using the code below.

``` {r}
#| label: Create the map

#rename variables
region <- dt_region |> rename(Environment = env, Zone = zone, "Sub-Zone" = sub_zone)

#group at selected level
#region <- region |> group_by("Sub-Zone") |> summarise(geometry = st_union(geometry))

#NOTE
#Environment: scalebar position = 0.15
#Zone: scalebar position = 0.17
#Sub_zone: scalebar position = 0.22

#plot the main map
mainmap <- tm_shape(qld) +
  tm_polygons(col = "grey80", border.col = "black") +
  tm_shape(region, is.master = TRUE) +
  tm_polygons(border.col = "black", alpha = 0.6, col = "Environment") +
  tm_shape(cities) +
  tm_dots(size = 1) +
  tm_shape(cities) +
  tm_dots(size = 0.3, col = "white") +
  tm_text("name", shadow = T, just = "right", xmod = -0.7) +
  tm_layout(legend.frame = T, legend.bg.color = "White", asp = 1.1, legend.text.size = 0.7, legend.position = c("left", "bottom")) +
  tm_scale_bar(width = 0.15, text.size = 0.7, position = c(0.15, 0)) +
  tm_compass(position = c("right", "top"))

#save
tmap_save(mainmap, "test.png")

```

These maps may also need an inset map to be included. The chunk below holds a rough example of this.

``` {r}
#| label: inset map
#| output: false

#get the x and y bbox coordinates, so we can determine aspect ratio of the main map
xy <- st_bbox(region)
asp1 <- (xy$ymax - xy$ymin)/(xy$xmax - xy$xmin)

#get the x and y coordinates, of our inset map so we can determine aspect ratio
xy <- st_bbox(qld)
asp2 <- (xy$ymax - xy$ymin)/(xy$xmax - xy$xmin)

#plot the inset map, overlay the bbox of the main map
insetmap <- tm_shape(qld) +
  tm_polygons(col = "grey80", border.col = "black") +
  tm_shape(bbox) + tm_borders(lw=1, col="red") +
  tm_layout(inner.margins = c(0,0,0,0), outer.margins=c(0,0,0,0),
            bg.color = "white")

#view the inset map
insetmap

#create the viewport for the inset map. width = width of legend in main map. 
#height is calculated by using the aspect ration of the inset map
#x for viewport is x for legend of main map minus the inner margin
w <- 0.2
h <- asp2*w
vp <- viewport(x = 0.975, y = 0.38, width = w, height = h, just = c("right", "top"))

#save the main map, inset the second map. Height and width of final image is
#determined using the aspect ratio of the main map
#tmap_save(mainmap, 
          #filename = "output/technical_report_maps/dry_tropics_full_boundaries.png",
          #dpi = 300, asp = 0, insets_tm = insetmap, insets_vp = vp,
          #height = asp1*100, width = 100, units = "mm")

```










