---
title: "Northern Three Mapping (Regional Ecosystem Measurements)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`"
format: html
params:
  project_crs: "EPSG:7844"
---

A script to assess remnant and pre-cleared regional ecosystem (RE) data in Townsville estuaries. This script is a work in progress script designed in an attempt to mimic the gis analysis DES provides for MWI and WT. 

# Initial Setup

Install packages and assign global project variables.

```{r}
#| label: establish global controls and settings
#| output: false

#mapping
library(terra)
library(sf)
library(tmap)

#extra utils
library(glue)
library(reactable)
library(tidyverse)

#set project variables
proj_crs <- params$project_crs

#format the date for the path below and to be used as a variable in naming later
date <- format(Sys.time(), "%Y-%m-%d")

#create a file path to help with saving things
save_path <- glue("output/{date}_n3-regional-ecosystems/")

#bring that path to life
dir.create(save_path)

#turn of spherical geometry
sf_use_s2(FALSE)

```

# Data Source

Load in the RE data and shapefiles. If this is the first time running the analysis please refer to the .README for this repo for a guide on downloading the data.

``` {r}
#| label: load in RE data
#| output: false

#read in data
re_remnant <- st_read(dsn = "data/regional_ecosystems/re_remnant.gpkg")
re_p_clear <- st_read(dsn = "data/regional_ecosystems/re_pre_clearing.gpkg")
dt_env <- st_read(dsn = "data/shapefiles",
                  layer = "Dry-Tropics-Basins-Detailed")
water_course <- st_read(dsn = "data/shapefiles",
                        layer = "Watercourse_areas")

#transform crs
re_remnant <- st_transform(re_remnant, proj_crs)
re_p_clear <- st_transform(re_p_clear, proj_crs)
water_course <- st_transform(water_course, proj_crs)

#read in DES's data
wt_mwi <- st_read("data/regional_ecosystems/Data_for_Adam.gdb")

#transform crs
wt_mwi <- st_transform(wt_mwi, proj_crs)

```

``` {r}
#| label: process DES data
#| output: false

#get a list of unique names 
names <- unique(wt_mwi$NAME)

#create an empty list to keep track of variables
output_names <- c()

#for each name
for (i in 1:length(names)){
  
  #filter for only that name
  df <- wt_mwi |> filter(str_detect(NAME, names[i]))
  
  #group everything up, summarise the geometry and remove z dimension
  df <- df |> group_by(NAME) |> summarise(Shape = st_union(Shape)) |> st_zm()
  
  #create a var name for the data
  var_name <- str_replace_all(names[i], c(" AREA" = "_est", " CREEK" = "_water", 
                                          " RIVERS" = "_water", " RIVER" = "_water",
                                          " INLET$" = "_water"))
  
  #make lowercase
  var_name <- tolower(var_name)
  
  #replace certain characters
  var_name <- str_replace_all(var_name, c(" / " = ".", "/" = ".", " " = "_", "'" = ""))
  
  #if var name has 3 elements,
  if (length(strsplit(var_name, "_")[[1]]) == 3){
    
    #combine first and third elements
    var_name <- paste(strsplit(var_name, "_")[[1]][1], strsplit(var_name, "_")[[1]][3], sep = "_")
    
  } 
  
  #assign data to variable
  assign(var_name, df)
  
  #keep track of names created
  output_names <- append(output_names, var_name)
  
}

```
# Data Analysis

## Establishing Estuarine Boundaries

The method used by DES is to select an arbitrary (but reasonable) boundary for the estuary in question. The code chuck below selects a boundary for the Black and Ross basins respectively. Here, the method is to use the estuarine boundaries as defined by the EPP layers that are used to define estuarine zones for the report card. Refer to the dt_basin_builder script on how these were ingested.

``` {r}
#| label: define estuarine boundaries
#| output: false

#filter for estuarine, and union everything together
black_est <- dt_env |> filter(zone == "black", env == "estuarine") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

ross_est <- dt_env |> filter(zone == "ross", env == "estuarine") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

```
Here is an example of how the boundaries look:

```{r}
#| label: show example of ross boundary

plot(st_geometry(ross_est))

```

## Establishing 50m Estuarine Waterway Buffer

The method used by DES is to select the main river within the estuary, create a 50m buffer around that river, and calculate the amount of vegetation within that buffer that is remnant vs non-remnant. Here, the selection of the main rivers within an estuary was based on the "watercourse_areas" shapefile provided by QSpatial. The rivers are then cut by the estuarine boundaries calculated above.

``` {r}
#| label: establishing wateway bundaries
#| output: false

#get water courses only within our region of interest and buffer by 50m
ross_water <- st_intersection(ross_est, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs)

black_water <- st_intersection(black_est, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs)

```

And here is an example of how the river buffers look:

``` {r}
#| label: show example of buffer

plot(st_geometry(ross_water))

```
## Create list of shapefiles to use

``` {r}

#add ross and black to list
output_names <- append(output_names, c("ross_water", "black_water", "ross_est", "black_est"))

#make alphabetical for clarity
output_names <- output_names[order(names(setNames(output_names, output_names)))]

#for now, remove elements that don't have both est and water
#output_names <- output_names[-c(19, 26, 27)]


```



We can also now save all of these spatial files. Other teams might be interested in reproducing the work.

``` {r}
#| label: save spatial layers
#| output: false

#dir.create("data/shapefiles/re_outputs/")

#st_write(black_est, dsn = "data/shapefiles/re_outputs/black_estuary.shp", delete_layer = T)
#st_write(ross_est, dsn = "data/shapefiles/re_outputs/ross_estuary.shp", delete_layer = T)
#st_write(black_water, dsn = "data/shapefiles/re_outputs/black_river_buff.shp", delete_layer = T)
#st_write(ross_water, dsn = "data/shapefiles/re_outputs/ross_river_buff.shp", delete_layer = T)
 
```

## Calculating Vegetation Cover

Once the boundaries are selected we can then use them to intersect the areas of the regional ecosystem layers that we care about.

``` {r}
#| label: select RE within estuaries
#| output: false

#create new list to track outputs
output_names2 <- c()

#using list of names of shapefiles to intersect over re layers
for (i in 1:length(output_names)){
  
  #estuary is in name
  if (strsplit(output_names, "_")[[1]][2] == "est"){
    
    #intersect element over remant veg and name appropriately
    assign(glue("{output_names[i]}_rem"), st_intersection(get(output_names[i]), re_remnant))
    
    #intersect element over pre-clear veg and name appropriately
    assign(glue("{output_names[i]}_pclear"), st_intersection(get(output_names[i]), re_p_clear))
    
    #track outputs
    output_names2 <- append(output_names2, c(glue("{output_names[i]}_rem"), glue("{output_names[i]}_pclear")))
    
  } else if (strsplit(output_names, "_")[[1]][2] == "water"){
    
    #intersect element over remant veg and name appropriately
    assign(glue("{output_names[i]}_rem"), st_intersection(get(output_names[i]), re_remnant))
    
    #intersect element over pre-clear veg and name appropriately
    assign(glue("{output_names[i]}_pclear"), st_intersection(get(output_names[i]), re_p_clear))
    
    #track outputs
    output_names2 <- append(output_names2, c(glue("{output_names[i]}_rem"), glue("{output_names[i]}_pclear")))
    
  }
}


for (i in 1:length(output_names2)){
  
  #if shape col name exists
  if ("Shape" %in% colnames(get(output_names2[i]))){
    
    #rename it to geometry
    assign(glue("{output_names2[i]}"), (get(glue("{output_names2[i]}")) |> rename(geometry = Shape)))
    
  } 
  
  #if name col exists
  if ("NAME" %in% colnames(get(output_names2[i]))){
    
    #remove it
    assign(glue("{output_names2[i]}"), (get(glue("{output_names2[i]}")) |> select(!NAME)))
    
  }
  
  #group up the ecosystems by Broad Vegetation type
  assign(glue("{output_names2[i]}"), (get(glue("{output_names2[i]}")) |> group_by(across(c(24, 25))) |> 
                                        summarise(geometry = st_union(geometry)) |> ungroup()))
}


```

Now we can calculate the area of each RE type and create a summary table.

``` {r}
#| label: calculate area
#| output: false

for (i in 1:length(output_names2)){
  
  #extract only polygons then group back up again
  df <- get(output_names2[i]) |> st_collection_extract(type = "POLYGON", warn = F) |> 
    group_by(across(1:2)) |> summarise(geometry = st_union(geometry))
  
  #calculate the area
  df <- df |> group_by(BVG1M) |> mutate(area_m = st_area(geometry))
  
  #update units to a more reasonable measure
  df$area_km <- units::set_units(df$area_m, km^2)
  
  #cleanup
  df <- df |> select(!area_m) |> ungroup()
  
  #assign df back to main
  assign(glue("{output_names2[i]}"), df)
  
  #clean up
  rm(df)
  
}

```

Below is a map of one area to help visualise what we now have:

``` {r}
#| label: show BVG1M

tmap_mode("view")

tm_shape(ross_est_rem) +
  tm_polygons(col = "BVG1M")

```

## Further Analysis

We can now start manipulating our summary data and exploring further. The code chunk below separates out areas that consist of more than one broad vegetation group and assigns each an area based on its percentage weighting of the total area it represents. Once this is done, the spatial geometry for each dataset must be dropped to continue the next steps. A file with geometry and areas at this point is saved to the shapefiles folder.

``` {r}
#| label: explore data
#| output: false

#create an empty list to track outputs of this loop
output_names3 <- c()

for (i in 1:length(output_names2)){
  
  #get the zone
  zone <- strsplit(output_names2[i], "_")[[1]][1]
  
  #get the area we are looking at
  area <- strsplit(output_names2[i], "_")[[1]][2]
  
  #get the re type
  re_type <- strsplit(output_names2[i], "_")[[1]][3]
  
  #split data with more than one BVG into multiple columns
  temp_df <- get(output_names2[i]) |>  
    separate(BVG1M, into = c("BVG1", "BVG2", "BVG3", "BVG4", "BVG5"), sep = "/") |> 
    separate(BVG1M_PC, into = c("PC1", "PC2", "PC3", "PC4", "PC5"), sep = "/") |> 
    mutate(across(c(6:10), as.numeric)) |> 
    mutate(PC1_area = (PC1*area_km)/100,
           PC2_area = (PC2*area_km)/100,
           PC3_area = (PC3*area_km)/100,
           PC4_area = (PC4*area_km)/100,
           PC5_area = (PC5*area_km)/100)
  
  #select only the bvg columns and pivot longer (keep geometry)
  bvg_temp <- temp_df |> select(starts_with("BVG")) |> 
    pivot_longer(c(1:5) , names_to = "BVG_group", values_to = "BVG")   
  
  #select only the percentage area columns and pivot longer (drop geometry)
  area_temp <- temp_df |> select(ends_with("_area")) |> st_drop_geometry() |> 
    pivot_longer(everything() , names_to = "area_group", values_to = "area_km") 
  
  #combine the two tables
  combined <- cbind(bvg_temp, area_temp)
      
  #select only the bvg and area columns, group by the bvg and summarise the areas, rename columns
  final <- combined |> select("BVG", "area_km") |> drop_na()|> 
    group_by(BVG) |> summarise(area_km = sum(area_km)) |> 
    rename("broad_vegetation_group" := BVG,
           "{re_type}_area_km" := area_km) 
  
  #save a spatial version
  st_write(final, dsn = glue("data/shapefiles/re_outputs/{output_names2[i]}.shp"),
           delete_layer = T)

  #drop the geometry
  final <- final |> st_drop_geometry()
  
  #assign the output to a summary table
  assign(glue("{zone}_{area}_{re_type}_summary"), final)
  
  #build a list of outputs for next loop
  output_names3 <- append(output_names3, glue("{zone}_{area}_{re_type}_summary"))
  
  #clean up
  rm(temp_df, bvg_temp, area_temp, combined, final)
}

```

Once the pre-clearing and remnant calculations have been performed for each region, the data for a region can then be combined into a single table and compared against one another. This code does the combination.

``` {r}
#| label: combine preclear and remnant
#| output: false

#assign an empty variable for unique zones
zone <- c()

#create empty list for new df create
output_names4 <- c()

#using the list from above
for (i in 1:length(output_names3)){
  
  #get a list of unique zones
  zone <- unique(append(zone, strsplit(output_names3[i], "_")[[1]][1]))
}

#assign a variable as 0km^2
a <- units::set_units(0, km^2) 
  
 
#for each zone
for (i in 1:length(zone)){
    
  #if at least one of the listed files exists
  if ((exists(glue("{zone[i]}_est_pclear_summary")) | exists(glue("{zone[i]}_est_rem_summary"))) == T){
      
    #join the two data frames together
    assign(glue("{zone[i]}_estuary_summary"), full_join(get(glue("{zone[i]}_est_pclear_summary")),
                                                get(glue("{zone[i]}_est_rem_summary"))) |>
             mutate(across(c(2:3), ~replace_na(.x, a))))
      
    #keep track of df created
    output_names4 <- append(output_names4, glue("{zone[i]}_estuary_summary"))
    
  } 
  #if at least one of the listed files exists  
  if ((exists(glue("{zone[i]}_water_pclear_summary")) | exists(glue("{zone[i]}_water_rem_summary"))) == T) {
      
    #join the two data frames together with different name
    assign(glue("{zone[i]}_river_summary"), full_join(get(glue("{zone[i]}_water_pclear_summary")),
                                                get(glue("{zone[i]}_water_rem_summary"))) |>
             mutate(across(c(2:3), ~replace_na(.x, a))))
      
    #keep track of df created
    output_names4 <- append(output_names4, glue("{zone[i]}_river_summary"))
  }
}

     


```

And this code calculates the area change and percentage change for vegetation groups.

``` {r}
#| label: calcuate percentage change
#| output: false

for (i in 1:length(output_names4)){
  
  #split data with more than one BVG into multiple columns
  temp_df <- get(output_names4[i]) |> 
    mutate(area_change = (rem_area_km-pclear_area_km)) |> 
    mutate(percentage_change = (area_change/pclear_area_km)*100)
  
  #update data type
  temp_df$percentage_change <-  as.numeric(temp_df$percentage_change)
  
  #round values
  temp_df <- temp_df |> mutate(across(where(is.numeric), round, 6))
  
  #replace Inf values with 100 (i.e. a 100% increase)
  temp_df$percentage_change <- ifelse(is.finite(temp_df$percentage_change), temp_df$percentage_change, 100)
  
  #assign the output to a summary table
  assign(glue("{output_names4[i]}"), temp_df)

}

```

These tables can now be saved to file.

``` {r}
#| label: save summary tables

for (i in 1:length(output_names4)){
  
  #get the zone
  zone <- strsplit(output_names4[i], "_")[[1]][1]
  
  #get the area we are looking at
  area <- strsplit(output_names4[i], "_")[[1]][2]
  
  #save the file
  write_csv(get(output_names4[i]), file = glue("{save_path}{zone}-{area}-summary.csv"))

}

library(openxlsx2)

save_list <- c()

for (i in 1:length(output_names4)){
  
  save_list <- append(save_list, list(get(output_names4[i])))
}

#name elements in list
names(save_list) <- output_names4

#save everything
write_xlsx(save_list, "regional_ecosystems_analysis.xlsx")



```

Here is an example of what has been calculated.

``` {r}
#| label: show example table

#visualise
reactable(ross_estuary_summary, highlight = T)

```



