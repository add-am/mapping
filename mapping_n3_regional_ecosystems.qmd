---
title: "Northern Three Mapping (Regional Ecosystem Measurements)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`"
format: html
params:
  project_crs: "EPSG:7844"
---

A script to assess remnant and pre-cleared regional ecosystem (RE) data in Townsville estuaries. This script is a work in progress script designed in an attempt to mimic the gis analysis DES provides for MWI and WT. 

# Initial Setup

Install packages and assign global project variables.

```{r}
#| label: establish global controls and settings
#| output: false

#mapping
library(terra)
library(sf)
library(tmap)

#extra utils
library(glue)
library(reactable)
library(tidyverse)

#set project variables
proj_crs <- params$project_crs

#format the date for the path below and to be used as a variable in naming later
date <- format(Sys.time(), "%Y-%m-%d")

#create a file path to help with saving things
save_path <- glue("output/{date}_n3-regional-ecosystems/")

#bring that path to life
dir.create(save_path)

#turn of spherical geometry
sf_use_s2(FALSE)

```

# Data Source

Load in the RE data and shapefiles. If this is the first time running the analysis please refer to the .README for this repo for a guide on downloading the data.

``` {r}
#| label: load in RE data
#| output: false

#read in data
re_remnant <- st_read(dsn = "data/regional_ecosystems/re_remnant.gpkg")
re_p_clear <- st_read(dsn = "data/regional_ecosystems/re_pre_clearing.gpkg")
dt_env <- st_read(dsn = "data/shapefiles",
                  layer = "Dry-Tropics-Basins-Detailed")
water_course <- st_read(dsn = "data/shapefiles",
                        layer = "Watercourse_areas")

#transform crs
re_remnant <- st_transform(re_remnant, proj_crs)
re_p_clear <- st_transform(re_p_clear, proj_crs)


```
# Data Analysis

## Establishing Estuarine Boundaries

The method used by DES is to select an arbitrary (but reasonable) boundary for the estuary in question. The code chuck below selects a boundary for the Black and Ross basins respectively. Here, the method is to use the estuarine boundaries as defined by the EPP layers that are used to define estuarine zones for the report card. Refer to the dt_basin_builder script on how these were ingested.

``` {r}
#| label: define estuarine boundaries
#| output: false

#filter for estuarine, and union everything together
black_est <- dt_env |> filter(zone == "black", env == "estuarine") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

ross_est <- dt_env |> filter(zone == "ross", env == "estuarine") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

```
Here is an example of how the boundaries look:

```{r}
#| label: show example of ross boundary

plot(st_geometry(ross_est))

```

## Establishing 50m Estuarine Waterway Buffer

The method used by DES is to select the main river within the estuary, create a 50m buffer around that river, and calculate the amount of vegetation within that buffer that is remnant vs non-remnant. Here, the selection of the main rivers within an estuary was based on the "watercourse_areas" shapefile provided by QSpatial. The rivers are then cut by the estuarine boundaries calculated above.

``` {r}
#| label: establishing wateway bundaries
#| output: false

#get water courses only within our region of interest and buffer by 50m
ross_water <- st_intersection(ross_est, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs)

black_water <- st_intersection(black_est, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs)

```

And here is an example of how the river buffers look:

``` {r}
#| label: show example of buffer

plot(st_geometry(ross_water))

```

We can also now save all of these spatial files. Other teams might be interested in reproducing the work.

``` {r}
#| label: save spatial layers
#| output: false

dir.create("data/shapefiles/re_outputs/")

st_write(black_est, dsn = "data/shapefiles/re_outputs/black_estuary.shp", delete_layer = T)
st_write(ross_est, dsn = "data/shapefiles/re_outputs/ross_estuary.shp", delete_layer = T)
st_write(black_water, dsn = "data/shapefiles/re_outputs/black_river_buff.shp", delete_layer = T)
st_write(ross_water, dsn = "data/shapefiles/re_outputs/ross_river_buff.shp", delete_layer = T)
 
```

## Calculating Vegetation Cover

Once the boundaries are selected we can then use them to intersect the areas of the regional ecosystem layers that we care about.

``` {r}
#| label: select RE within estuaries
#| output: false

#get re layer within est bounds
black_rem <- st_intersection(black_est, re_remnant)
ross_rem <- st_intersection(ross_est, re_remnant)
black_pclear <- st_intersection(black_est, re_p_clear)
ross_pclear <- st_intersection(ross_est, re_p_clear)

#get re layer within river buffer bounds
black_rem_buff <- st_intersection(black_water, re_remnant)
ross_rem_buff <- st_intersection(ross_water, re_remnant)
black_pclear_buff <- st_intersection(black_water, re_p_clear)
ross_pclear_buff <- st_intersection(ross_water, re_p_clear)

#create a list of files to loop over
file_list <- c("black_rem", "ross_rem", "black_pclear", "ross_pclear", "black_rem_buff", "ross_rem_buff",
               "black_pclear_buff", "ross_pclear_buff")

for (i in 1:length(file_list)){

  #group up the ecosystems by Broad Vegetation type
  assign(glue("{file_list[i]}"), (get(glue("{file_list[i]}")) |> group_by(across(c(24, 25))) |> 
                                    summarise(geometry = st_union(geometry)) |> ungroup()))
}


```

Now we can calculate the area of each RE type and create a summary table.

``` {r}
#| label: calculate area
#| output: false

#create an new empty list to track outputs of loop
output_dfs <- c()

for (i in 1:length(file_list)){
  
  #extract only polygons then group back up again
  df <- get(file_list[i]) |> st_collection_extract(type = "POLYGON", warn = F) |> 
    group_by(across(1:2)) |> summarise(geometry = st_union(geometry))
  
  #calculate the area
  df <- df |> group_by(BVG1M) |> mutate(area_m = st_area(geometry))
  
  #update units to a more reasonable measure
  df$area_km <- units::set_units(df$area_m, km^2)
  
  #cleanup
  df <- df |> select(!area_m) |> ungroup()
  
  #assign df back to main
  assign(glue("{file_list[i]}_area"), df)
  
  #build list of df that are output
  output_dfs <- append(output_dfs, glue("{file_list[i]}_area"))
  
  #clean up
  rm(df)
  
}

```

Below is a map of one area to help visualise what we now have:

``` {r}
#| label: show BVG1M

plot(st_geometry(ross_rem_area), col = sf.colors())

```

## Further Analysis

We can now start manipulating our summary data and exploring further. The code chunk below separates out areas that consist of more than one broad vegetation group and assigns each an area based on its percentage weighting of the total area it represents. Once this is done, the spatial geometry for each dataset must be dropped to continue the next steps. A file with geometry and areas at this point is saved to the shapefiles folder.

``` {r}
#| label: explore data
#| output: false

#create an empty list to track outputs of this loop
output_dfs2 <- c()

for (i in 1:length(output_dfs)){
  
  #get the zone
  zone <- strsplit(output_dfs[i], "_")[[1]][1]
  
  #get the re type
  re_type <- strsplit(output_dfs[i], "_")[[1]][2]
  
  #get the area we are looking at
  area <- strsplit(output_dfs[i], "_")[[1]][3]

  #split data with more than one BVG into multiple columns
  temp_df <- get(output_dfs[i]) |>  
    separate(BVG1M, into = c("BVG1", "BVG2", "BVG3", "BVG4", "BVG5"), sep = "/") |> 
    separate(BVG1M_PC, into = c("PC1", "PC2", "PC3", "PC4", "PC5"), sep = "/") |> 
    mutate(across(c(6:10), as.numeric)) |> 
    mutate(PC1_area = PC1*area_km,
           PC2_area = PC2*area_km,
           PC3_area = PC3*area_km,
           PC4_area = PC4*area_km,
           PC5_area = PC5*area_km)
  
  #select only the bvg columns and pivot longer (keep geometry)
  bvg_temp <- temp_df |> select(starts_with("BVG")) |> 
    pivot_longer(c(1:5) , names_to = "BVG_group", values_to = "BVG")   
  
  #select only the percentage area columns and pivot longer (drop geometry)
  area_temp <- temp_df |> select(ends_with("_area")) |> st_drop_geometry() |> 
    pivot_longer(everything() , names_to = "area_group", values_to = "area_km") 
  
  #combine the two tables
  combined <- cbind(bvg_temp, area_temp)
      
  #select only the bvg and area columns, group by the bvg and summarise the areas, rename columns
  final <- combined |> select("BVG", "area_km") |> drop_na()|> 
    group_by(BVG) |> summarise(area_km = sum(area_km)) |> 
    rename("broad_vegetation_group" := BVG,
           "{re_type}_area_km" := area_km) 
  
  #save a spatial version
  st_write(final, dsn = glue("data/shapefiles/re_outputs/{output_dfs[i]}.shp"),
           delete_layer = T)

  #drop the geometry
  final <- final |> st_drop_geometry()
  
  #assign the output to a summary table
  assign(glue("{zone}_{re_type}_{area}_summary"), final)
  
  #build a list of outputs for next loop
  output_dfs2 <- append(output_dfs2, glue("{zone}_{re_type}_{area}_summary"))
  
  #clean up
  rm(temp_df, bvg_temp, area_temp, combined, final)
}

```

Once the pre-clearing and remnant calculations have been performed for each region, the data for a region can then be combined into a single table and compared against one another. This code does the combination.

``` {r}
#| label: combine preclear and remnant
#| output: false

#assign an empty variable for unique zones
zone <- c()

#create empty list for new df create
output_dfs3 <- c()

#using the list from above
for (i in 1:length(output_dfs2)){
  
  #get a list of unique zones
  zone <- unique(append(zone, strsplit(output_dfs2[i], "_")[[1]][1]))
}

#create choice for area we are looking
area <- c("area", "buff")

#assign a variable as 0km^2
a <- units::set_units(0, km^2) 
  
#using the two area choices
for (i in 1:length(area)){
  
  #if area choice is area
  if (area[i] == "area"){
    
    #for each zone
    for (i in 1:length(zone)){
      
      #join the two data frames together
      assign(glue("{zone[i]}_estuary_summary"), full_join(get(glue("{zone[i]}_pclear_area_summary")),
                                                  get(glue("{zone[i]}_rem_area_summary"))) |>
               mutate(across(c(2:3), ~replace_na(.x, a))))
      
      #keep track of df created
      output_dfs3 <- append(output_dfs3, glue("{zone[i]}_estuary_summary"))
    }
    
  #if area choice is not area 
  } else {
    
    #for each zone
    for (i in 1:length(zone)){
      
      #join the two data frames together with different name
      assign(glue("{zone[i]}_river_buffer_summary"), full_join(get(glue("{zone[i]}_pclear_buff_summary")),
                                                  get(glue("{zone[i]}_rem_buff_summary"))) |>
               mutate(across(c(2:3), ~replace_na(.x, a))))
      
      #keep track of df created
      output_dfs3 <- append(output_dfs3, glue("{zone[i]}_river_buffer_summary"))
    }
  }
}

```

And this code calculates the area change and percentage change for vegetation groups.

``` {r}
#| label: calcuate percentage change
#| output: false

for (i in 1:length(output_dfs3)){
  
  #split data with more than one BVG into multiple columns
  temp_df <- get(output_dfs3[i]) |> 
    mutate(area_change = (rem_area_km-pclear_area_km)) |> 
    mutate(percentage_change = (area_change/pclear_area_km)*100)
  
  #update data type
  temp_df$percentage_change <-  as.numeric(temp_df$percentage_change)
  
  #round values
  temp_df <- temp_df |> mutate(across(where(is.numeric), round, 2))
  
  #assign the output to a summary table
  assign(glue("{output_dfs3[i]}"), temp_df)

}

```

These tables can now be saved to file.

``` {r}
#| label: save summary tables

for (i in 1:length(output_dfs3)){
  
  #get the zone
  zone <- strsplit(output_dfs3[i], "_")[[1]][1]
  
  #get the area we are looking at
  area <- strsplit(output_dfs3[i], "_")[[1]][2]
  
  #save the file
  write_csv(get(output_dfs3[i]), file = glue("{save_path}{zone}-{area}-summary.csv"))
}

```

Here is an example of what has been calculated.

``` {r}
#| label: show example table

#visualise
reactable(ross_estuary_summary, highlight = T)

```



