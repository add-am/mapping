---
title: "Northern Three Mapping (Regional Ecosystem Measurements)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`"
format: html
params:
  project_crs: "EPSG:7844"
---

A script to assess remnant and pre-cleared regional ecosystem (RE) data in the Northern Three region. Currently this script only calculates RE changes for:

- the estuarine zone of each basin
- the 50m buffer either side of the main rivers within the estuarine zone of each basin

Note that there is potential to calculate RE changes for the freshwater zone and freshwater portion of the rivers as well.

This script is under works to complete RE calculations for:

- the freshwater zone of each basin
- the 50m buffer either side of the main rivers within the freshwater zone of each basin

# Initial Setup

Install packages and assign global project variables.

```{r}
#| label: establish global controls and settings
#| output: false

#mapping
library(terra)
library(sf)
library(tmap)

#extra utils
library(glue)
library(reactable)
library(tidyverse)
library(openxlsx2)

#set project variables
proj_crs <- params$project_crs

#format the date for the path below and to be used as a variable in naming later
date <- format(Sys.time(), "%Y-%m-%d")

#create a file path to help with saving things
save_path <- glue("output/{date}_n3-regional-ecosystems/")

#bring that path to life
dir.create(save_path)

#turn of spherical geometry
sf_use_s2(FALSE)

#turn on interactive mapping
tmap_mode("view")

```

# Data Source

Load in the RE data and shapefiles. If this is the first time running the analysis please refer to the .README for this repo for a guide on downloading the data.

``` {r}
#| label: load in RE data
#| output: false

#read in regional ecosystem data
re_remnant <- st_read(dsn = "data/regional_ecosystems/re_remnant.gpkg")
re_p_clear <- st_read(dsn = "data/regional_ecosystems/re_pre_clearing.gpkg")

#read in water course shapefile
water_course <- st_read(dsn = "data/shapefiles", layer = "Watercourse_areas")

#read in dry tropics estuarine zones
dt_env <- st_read(dsn = "data/shapefiles",layer = "Dry-Tropics-Basins-Detailed")

#read in wet tropics and Mackay estuarine zones
wt_mwi <- st_read("data/shapefiles/wt_mwi_re_areas.gdb")

#read the drainage basins and drainage basin sub areas
basins <- st_read(dsn = "data/shapefiles/Drainage_basins.shp")
sub_basins <- st_read(dsn = "data/shapefiles/Drainage_basin_sub_areas.shp")

#transform crs
re_remnant <- st_transform(re_remnant, proj_crs)
re_p_clear <- st_transform(re_p_clear, proj_crs)
water_course <- st_transform(water_course, proj_crs)
dt_env <- st_transform(dt_env, proj_crs)
wt_mwi <- st_transform(wt_mwi, proj_crs)
basins <- st_transform(basins, proj_crs)
sub_basins <- st_transform(sub_basins, proj_crs)


```
# Data Preparation

Before we can analyse the RE layers, we first need to do some data preparations. Specifically we need to:

- select only the Northern Three basins
- wrangle the DES data into a format that works with the rest of the data
- use the DES data and estuarine boundaries to split the N3 basins into "estuarine" and "not estuarine" i.e. fresh
- create the 50m buffers either side of the main rivers in each basin
- divide these buffers into either estuarine or fresh

Each code chunk below address at least one of these steps.

## Specify the target basins

```{r}
#| label: Prep Basin Shapefiles
#| output: false

#select northern three basins based on list of names
n3_basins <- basins %>% 
  filter(BASIN_NAME %in% c("Ross", "Black", "Don", "Proserpine", "O'Connell", 
                           "Pioneer", "Plane", "Daintree", "Mossman", "Barron", 
                           "Johnstone", "Tully", "Murray", "Herbert"))

#wet tropics split mulgrave-russell into two separate sub basins.
#get Russell and Mulgrave River from sub_basins
temp <- sub_basins %>% 
  filter(SUB_NAME %in% c("Russell River", "Mulgrave River")) %>% 
  mutate(SUB_NAME = case_when(SUB_NAME == "Russell River" ~ "Russell",
                              SUB_NAME == "Mulgrave River" ~ "Mulgrave")) %>% 
  rename(BASIN_NAME = SUB_NAME, BASIN_NUMB = SUB_NUMBER)

#add the two basins onto main
n3_basins <- rbind(n3_basins, temp)

#clean up
rm(temp, basins, sub_basins)

#remove unwanted vars and add regional context
n3_basins <- n3_basins %>% 
  select(BASIN_NAME) %>% 
  rename(basin = BASIN_NAME) %>% 
  mutate(region = case_when(
    str_detect(basin, "Ross|Black") ~ "Dry Tropics",
    str_detect(basin, "Dain|Moss|Barr|John|Tull|Murr|Herb|Mulg|Russ") ~ "Wet Tropics",
    str_detect(basin, "Don|Proser|O'|Pio|Plane") ~ "Mackay Whitsunday Isaac"
    ), .after = basin)

```

## Create WT and MWI estuarine area and estuarine river buffer

The data provided by DES for the wt and mwi estuarine zones currently requires some wrangling to manipulate it into a structure that works with the script.
``` {r}
#| label: process DES data
#| output: false

#get a list of unique names 
names <- unique(wt_mwi$NAME)

#create an empty list to keep track of variables
output_names <- c()

#for each name
for (i in 1:length(names)){
  
  #filter for only that name
  df <- wt_mwi |> filter(str_detect(NAME, glue("{names[i]}$")))
  
  #group everything up, summarise the geometry and remove z dimension
  df <- df |> group_by(NAME) |> summarise(Shape = st_union(Shape)) |> st_zm()
  
  #create a var name for the data to be saved with
  var_name <- str_replace_all(names[i], c(" AREA" = "_est", " CREEK" = "_ebuff", 
                                          " RIVERS" = "_ebuff", " RIVER" = "_ebuff",
                                          " INLET$" = "_ebuff"))
  
  #make lowercase
  var_name <- tolower(var_name)
  
  #replace certain characters
  var_name <- str_replace_all(var_name, c(" / " = ".", "/" = ".", " " = "_", "'" = ""))
  
  #if var name has 3 elements,
  if (length(strsplit(var_name, "_")[[1]]) == 3){
    
    #delete the second element
    var_name <- paste(strsplit(var_name, "_")[[1]][1], strsplit(var_name, "_")[[1]][3], sep = "_")
    
  } 
  
  #assign data to variable
  assign(var_name, df)
  
  #keep track of names created
  output_names <- append(output_names, var_name)
  
}

```

## Create WT and MWI fresh area

The method used by DES for the Wet Tropics and Mackay Whitsunday Issac is to select an arbitrary (but reasonable) boundary for the estuary in question. We can these use this estuary to mask each basin, which returns everything "not estuarine" which is assumed to be fresh. There are caveats there such as the fact that DES doesn't designate all estuarine areas - but we will cross that bridge later.

``` {r}
#| label: create fresh areas for other n3 regions
#| output: false

#create condition
first_est <- T

#merge all estuarine areas into one shape
for (i in 1:length(output_names)){
  
  #on first estuary loop
  if (strsplit(output_names[i], "_")[[1]][2] == "est" & first_est == T){
    
    #create the estuary shapefile
    all_est <- get(output_names[i])
    
    #update condition
    first_est <- F
    
    #on every other estuary loop
  } else if (strsplit(output_names[i], "_")[[1]][2] == "est") {
      
    #write to a temp file
    temp_sf <- get(output_names[i])
    
    #add the temp file to the main shapefile
    all_est <- rbind(all_est, temp_sf)
      
  }
  
}

#merge into a single polygon and remove holes
all_est <- all_est |> summarise(geometry = st_union(Shape)) |> st_union(by_feature = FALSE) |> 
  st_combine() |>  nngeo::st_remove_holes() |> st_sf()

#return the difference between the estuary area and the basins to return the fresh areas
all_fresh <- st_difference(n3_basins, all_est)

#edit the sf
all_fresh <- all_fresh |> filter(region != "Dry Tropics") |> 
  select(!region) |> rename(NAME = basin)

#get a list of unique basin names all in lower case
basin_names <- tolower(unique(all_fresh$NAME))

#replace the ' character
basin_names <- str_replace_all(basin_names, c("'" = ""))

#create an empty vector
names_to_add <- c()

#split all the basins into separate shapefiles so that they can be manipulated the same way
for (i in 1:length(basin_names)){
  
  #create the new shapefile
  assign(glue("{basin_names[i]}_fresh"), slice(all_fresh, i))
  
  #keep track of the names created
  names_to_add <- append(names_to_add, glue("{basin_names[i]}_fresh"))
}

#add the new shapefiles to the tracker
output_names <- append(output_names, names_to_add)

#cleanup
rm(temp_sf, all_est, all_fresh, basin_names, names_to_add)


```

An example of the area create is below, note the circular holes at the river mouths - these are the estuarine areas.

``` {r}
#| label: show DES areas

tm_shape(johnstone_fresh) +
  tm_polygons(border.col = "red")


```

## Create DT estuarine area and fresh area

For the Dry Tropics we will use the estuarine and fresh boundaries as defined by the EPP maps. (Refer to the dt_basin_builder script on how these were ingested into the dry tropics maps).

:::{.callout-note}
There is the possibility to create similar map structures for the other n3 regions , but for now that hasn't occurred.
:::

``` {r}
#| label: define DT estuarine and fresh boundaries
#| output: false

#filter for estuarine, and union everything together
black_est <- dt_env |> filter(zone == "black", env == "estuarine") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

ross_est <- dt_env |> filter(zone == "ross", env == "estuarine") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

#filter for fresh, and union everything together
black_fresh <- dt_env |> filter(zone == "black", env == "fresh") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

ross_fresh <- dt_env |> filter(zone == "ross", env == "fresh") |> 
  summarise(geometry = st_union(geometry)) |> st_transform(proj_crs)

```
Here is an example of how the Dry Tropics boundaries look:

```{r}
#| label: show example of ross boundary

tm_shape(ross_est) +
  tm_polygons(border.col = "red")

```

## Create DT estuarine river buffer and fresh river buffer

The method used by DES is to select the main river within the estuary, and manually create a 50m buffer around that river. Here, the selection of the main rivers was based on the "watercourse_areas" shapefile provided by QSpatial. The rivers are then cut by the estuarine and fresh boundaries calculated above.

``` {r}
#| label: establishing wateway bundaries
#| output: false

#get water courses only within our est region of interest and buffer by 50m, remove holes
ross_ebuff <- st_intersection(ross_est, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs) #|> st_union(by_feature = FALSE) |> st_combine() |> 
  #nngeo::st_remove_holes() |> st_sf()

black_ebuff <- st_intersection(black_est, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs) #|> st_union(by_feature = FALSE) |> st_combine() |> 
  #nngeo::st_remove_holes() |> st_sf()

#get water courses only within our fresh region of interest and buffer by 50m, remove holes
ross_fbuff <- st_intersection(ross_fresh, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs) #|> st_union(by_feature = FALSE) |> st_combine() |> 
  #nngeo::st_remove_holes() |> st_sf()

black_fbuff <- st_intersection(black_fresh, water_course) |> 
  summarise(geometry = st_union(geometry)) |> st_transform(28356) |> st_buffer(dist = 50) |> 
  st_transform(proj_crs) #|> st_union(by_feature = FALSE) |> st_combine() |> 
  #nngeo::st_remove_holes() |> st_sf()

```

And here is an example of how the river buffers look, note that in some areas it can appear patchy. This is due to the underlying EPP designation of fresh or estuary - which is also patchy.

``` {r}
#| label: show example of buffer

tm_shape(ross_fbuff) +
  tm_polygons(border.col = "red")
  

```
## Finalise the list of shapefiles to use

This script relies on creating a list that keeps track of all the shapefiles created, as each shapefile is its own variable. All the current shapefiles are list below.

``` {r}

#add ross and black to list
output_names <- append(output_names, c("ross_ebuff", "black_ebuff", "ross_est", "black_est", 
                                       "ross_fbuff", "black_fbuff", "ross_fresh", "black_fresh"))

#make alphabetical for clarity
output_names <- output_names[order(names(setNames(output_names, output_names)))]

#print names
output_names

```


# Data Analysis

Now all the data preparation is complete and we have a list of shapefiles that we will be using we can begin the analysis.

## Calculating Vegetation Cover

Use the layers to intersect the areas of the regional ecosystem layers that we care about, and return only RE groups within.

``` {r}
#| label: select RE within estuaries
#| output: false

#create new list to track outputs
output_names2 <- c()

#using list of names of shapefiles to intersect over re layers
for (i in 1:length(output_names)){
  
  #intersect element over remnant veg and name appropriately
  assign(glue("{output_names[i]}_rem"), st_intersection(get(output_names[i]), re_remnant))
    
  #intersect element over pre-clear veg and name appropriately
  assign(glue("{output_names[i]}_pclear"), st_intersection(get(output_names[i]), re_p_clear))
    
  #track outputs
  output_names2 <- append(output_names2, c(glue("{output_names[i]}_rem"), glue("{output_names[i]}_pclear")))
  
}

```

Clean the data sets and group rows by RE type.

``` {r}
#| label: clean data
#| output: false

for (i in 1:length(output_names2)){
  
  #if shape col name exists
  if ("Shape" %in% colnames(get(output_names2[i]))){
    
    #rename it to geometry
    assign(glue("{output_names2[i]}"), (get(glue("{output_names2[i]}")) |> rename(geometry = Shape)))
    
  } 
  
  #if name col exists
  if ("NAME" %in% colnames(get(output_names2[i]))){
    
    #remove it
    assign(glue("{output_names2[i]}"), (get(glue("{output_names2[i]}")) |> select(!NAME)))
    
  }
  
  #group up the ecosystems by Regional Ecosystem type
  assign(glue("{output_names2[i]}"), (get(glue("{output_names2[i]}")) |> group_by(across(c(1, 7))) |> 
                                        summarise(geometry = st_union(geometry)) |> ungroup()))
}


```

Calculate the total area of each RE group.

``` {r}
#| label: calculate area
#| output: false

for (i in 1:length(output_names2)){
  
  #extract only polygons then group back up again
  df <- get(output_names2[i]) |> st_collection_extract(type = "POLYGON", warn = F) |> 
    group_by(across(1:2)) |> summarise(geometry = st_union(geometry))
  
  #calculate the area
  df <- df |> group_by(RE) |> mutate(area_m = st_area(geometry))
  
  #update units to a more reasonable measure
  df$area_km <- units::set_units(df$area_m, km^2)
  
  #cleanup
  df <- df |> select(!area_m) |> ungroup()
  
  #assign df back to main
  assign(glue("{output_names2[i]}"), df)
  
  #clean up
  rm(df)
  
}

```

Below is a map of some areas to help visualise what we now have:

``` {r}
#| label: show BVG1M

tm_shape(ross_est_rem) +
  tm_polygons(col = "RE") +
  tm_shape(ross_fbuff_rem) +
  tm_polygons(col =)

```

## Vegetation Cover Change over time

We can now start manipulating our summary data and exploring further. The code chunk below separates out areas that consist of more than one regional ecosystem group and assigns each an area based on its percentage weighting of the total area it represents. Once this is done, the spatial geometry for each dataset must be dropped to continue the next steps.

``` {r}
#| label: explore data
#| output: false

#create an empty list to track outputs of this loop
output_names3 <- c()

for (i in 1:length(output_names2)){
  
  #get the zone
  zone <- strsplit(output_names2[i], "_")[[1]][1]
  
  #get the area we are looking at
  area <- strsplit(output_names2[i], "_")[[1]][2]
  
  #get the re type
  re_type <- strsplit(output_names2[i], "_")[[1]][3]
  
  #split data with more than one RE into multiple columns
  temp_df <- get(output_names2[i]) |>  
    separate(RE, into = c("RE1", "RE2", "RE3", "RE4", "RE5"), sep = "/") |> 
    separate(PERCENT, into = c("PC1", "PC2", "PC3", "PC4", "PC5"), sep = "/") |> 
    mutate(across(c(6:10), as.numeric)) |> 
    mutate(PC1_area = (PC1*area_km)/100,
           PC2_area = (PC2*area_km)/100,
           PC3_area = (PC3*area_km)/100,
           PC4_area = (PC4*area_km)/100,
           PC5_area = (PC5*area_km)/100)
  
  #select only the RE columns and pivot longer (keep geometry)
  re_temp <- temp_df |> select(starts_with("RE")) |> 
    pivot_longer(c(1:5) , names_to = "RE_group", values_to = "RE")   
  
  #select only the percentage area columns and pivot longer (drop geometry)
  area_temp <- temp_df |> select(ends_with("_area")) |> st_drop_geometry() |> 
    pivot_longer(everything() , names_to = "area_group", values_to = "area_km") 
  
  #combine the two tables
  combined <- cbind(re_temp, area_temp)
      
  #select only the re and area columns, group by the re and summarise the areas, rename columns
  final <- combined |> select("RE", "area_km") |> drop_na()|> 
    group_by(RE) |> summarise(area_km = sum(area_km)) |> 
    rename("regional_ecosystem_group" := RE,
           "{re_type}_area_km" := area_km) 
  
  #drop the geometry
  final <- final |> st_drop_geometry()
  
  #assign the output to a summary table
  assign(glue("{zone}_{area}_{re_type}_summary"), final)
  
  #build a list of outputs for next loop
  output_names3 <- append(output_names3, glue("{zone}_{area}_{re_type}_summary"))
  
  #clean up
  rm(temp_df, re_temp, area_temp, combined, final)
}

```

Once the pre-clearing and remnant calculations have been performed for each region, the data for a region can then be combined into a single table and compared against one another. This code does the combination.

``` {r}
#| label: combine preclear and remnant
#| output: false

#assign an empty variable for unique zones
zone <- c()

#create empty list for new df create
output_names4 <- c()

#using the list from above
for (i in 1:length(output_names3)){
  
  #get a list of unique zones
  zone <- unique(append(zone, strsplit(output_names3[i], "_")[[1]][1]))
}

#assign a variable as 0km^2
a <- units::set_units(0, km^2) 
 
#for each zone
for (i in 1:length(zone)){
    
  #if at least one of the listed files exists
  if ((exists(glue("{zone[i]}_est_pclear_summary")) | exists(glue("{zone[i]}_est_rem_summary"))) == T){
      
    #join the two data frames together and replace any resulting na values with 0km^2
    assign(glue("{zone[i]}_estuary_summary"), full_join(get(glue("{zone[i]}_est_pclear_summary")),
                                                get(glue("{zone[i]}_est_rem_summary"))) |>
             mutate(across(c(2:3), ~replace_na(.x, a))))
      
    #keep track of df created
    output_names4 <- append(output_names4, glue("{zone[i]}_estuary_summary"))
    
  } 
  #if at least one of the listed files exists  
  if ((exists(glue("{zone[i]}_ebuff_pclear_summary")) | exists(glue("{zone[i]}_ebuff_rem_summary"))) == T) {
      
    #join the two data frames together with different name and replace any resulting na values with 0km^2
    assign(glue("{zone[i]}_eriver_summary"), full_join(get(glue("{zone[i]}_ebuff_pclear_summary")),
                                                get(glue("{zone[i]}_ebuff_rem_summary"))) |>
             mutate(across(c(2:3), ~replace_na(.x, a))))
      
    #keep track of df created
    output_names4 <- append(output_names4, glue("{zone[i]}_eriver_summary"))
  }
  #if at least one of the listed files exists
  if ((exists(glue("{zone[i]}_fresh_pclear_summary")) | exists(glue("{zone[i]}_fresh_rem_summary"))) == T){
      
    #join the two data frames together and replace any resulting na values with 0km^2
    assign(glue("{zone[i]}_fresh_summary"), full_join(get(glue("{zone[i]}_fresh_pclear_summary")),
                                                get(glue("{zone[i]}_fresh_rem_summary"))) |>
             mutate(across(c(2:3), ~replace_na(.x, a))))
      
    #keep track of df created
    output_names4 <- append(output_names4, glue("{zone[i]}_fresh_summary"))
    
  } 
  #if at least one of the listed files exists  
  if ((exists(glue("{zone[i]}_fbuff_pclear_summary")) | exists(glue("{zone[i]}_fbuff_rem_summary"))) == T) {
      
    #join the two data frames together with different name and replace any resulting na values with 0km^2
    assign(glue("{zone[i]}_friver_summary"), full_join(get(glue("{zone[i]}_fbuff_pclear_summary")),
                                                get(glue("{zone[i]}_fbuff_rem_summary"))) |>
             mutate(across(c(2:3), ~replace_na(.x, a))))
      
    #keep track of df created
    output_names4 <- append(output_names4, glue("{zone[i]}_friver_summary"))
  }
  
}

     


```

And this code calculates the sum remnant area, and the sum area of specific RE groups, these groups are **X.1.1 - X.1.5** inclusive, where X varies depending on the region: Wet Tropics: 7, Dry Tropics: 11, Mackay Whitsunday Isaac: 8. This calculation currently only applies to the full estuarine area, rather than both the estuarine area and the river buffer area.

The also then calculates area change and percentage change for each row, and the total area of each location.

For an explanation on RE groups refer to the .README for links to external resources.

``` {r}
#| label: calcuate percentage change
#| output: false

for (i in 1:length(output_names4)){
  
  #pull out all remnant and get the sum
  temp_df <- get(output_names4[i]) |> filter(regional_ecosystem_group != "non-remnant") |> 
    summarise(pclear_area_km = sum(pclear_area_km), rem_area_km = sum(rem_area_km)) |> 
    mutate(regional_ecosystem_group = "remnant_total")
  
  #bind back to main
  temp_df1 <- rbind(get(output_names4[i]), temp_df)
  
  #select only those with estuary in name
  if (strsplit(output_names4[i], "_")[[1]][2] == "estuary"){
    
    #filter to select specific RE groups
    temp_df2 <- get(output_names4[i]) |> 
      filter(str_detect(regional_ecosystem_group, c("\\d.1.1|\\d.1.2|\\d.1.3|\\d.1.4|\\d.1.5"))) |> 
      summarise(across(where(is.numeric), list(sum))) |> 
      rename(pclear_area_km = pclear_area_km_1, rem_area_km = rem_area_km_1) |> 
      mutate(regional_ecosystem_group = "target_re_group")
    
    #bind the summary row back onto main
    temp_df3 <- rbind(temp_df1, temp_df2)
    
  } else {temp_df3 <- temp_df1}
  
  #calculate total area for the location
  temp_df4 <- temp_df3 |> filter(regional_ecosystem_group %in% c("non-remnant","remnant_total")) |> 
    summarise(across(where(is.numeric), list(sum))) |> 
    rename(pclear_area_km = pclear_area_km_1, rem_area_km = rem_area_km_1) |> 
    mutate(regional_ecosystem_group = "total_area")
  
  #bind the summary row back onto main
  temp_df4 <- rbind(temp_df3, temp_df4)
  
  #calculate area change and the percentage change
  temp_df4 <- temp_df4 |> 
    mutate(area_change = (rem_area_km-pclear_area_km)) |> 
    mutate(percentage_change = (area_change/pclear_area_km)*100)
  
  #update data type
  temp_df4$percentage_change <-  as.numeric(temp_df4$percentage_change)
  
  #replace Inf values with 100 (i.e. a 100% increase)
  temp_df4$percentage_change <- ifelse(is.finite(temp_df4$percentage_change), temp_df4$percentage_change, 100)
  
  #assign the output back to the input name
  assign(glue("{output_names4[i]}"), temp_df4)

}

#cleanup
rm(temp_df, temp_df1, temp_df2, temp_df3, temp_df4)

```

# Data Presentation

We can then combine elements from all of these tables to create one large summary table.

``` {r}
#|label: create final summary table
#|output: false

#create empty tibble
final_summary <- tibble()

#create list to match
matches <- c("non-remnant", "remnant_total", "target_re_group", "total_area")

for (i in 1:length(output_names4)){
  
  #select the zone from the data fram name
  zone <- strsplit(output_names4[i], "_")[[1]][1]
  
  #select the focus area
  area <- strsplit(output_names4[i], "_")[[1]][2]
  
  #add as a col
  df <- get(output_names4[i]) |> 
    mutate(zone = zone, .before = regional_ecosystem_group) |> 
    mutate(area = area, .before = regional_ecosystem_group)
  
  #select specific rows
  df <- df |> filter(regional_ecosystem_group %in% matches)
  
  #bind to main
  final_summary <- rbind(final_summary, df)
}

#round all numeric values
final_summary <- final_summary |> mutate(across(where(is.numeric), round, 6))

#round percentage values further
final_summary$percentage_change <- round(final_summary$percentage_change, 2)


```



The full data tables and the main summary table can now be saved to file.

``` {r}
#| label: save summary tables

#save the big summary table
write_csv(final_summary, file = glue("{save_path}regional_ecosystems_summary.csv"))

#create an empty list
save_list <- c()

#fill list with full data table variable names
for (i in 1:length(output_names4)){
  
  save_list <- append(save_list, list(get(output_names4[i])))
}

#name elements in list
names(save_list) <- output_names4

#save everything
write_xlsx(save_list, glue("{save_path}regional_ecosystems_full_data.xlsx"))



```

Here is main summary table.

``` {r}
#| label: show example table

#visualise
reactable(final_summary, highlight = T)

```



