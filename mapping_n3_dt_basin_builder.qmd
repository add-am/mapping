---
title: "Northern Three Mapping (Basin Builder)"
author: "Adam Shand"
date: "`r format(Sys.time(), '%d, %B, %Y')`" 
format: html
params:
  project_crs: "EPSG:7844"
---

A script to create the custom divisions of the Dry Tropics Basins and Marine zone. This uses multiple publicly available datasets.

# Global Controls

Before diving in, we must establish some global variables that provide critical control over the output.

```{r}
#| label: get remotes package and install extra packages
#| output: false

#check if remotes is installed
package_list <- c("remotes")
new_packages <- package_list[!(package_list %in% installed.packages()[,"Package"])]

#if length is anything but zero, install remotes
if(length(new_packages)) install.packages(new_packages)

#check if gisaimsr data package is installed
package_list <- c("gisaimsr")
new_packages <- package_list[!(package_list %in% installed.packages()[,"Package"])]

#if length is anything but zero, install gisaimsr
if(length(new_packages)) remotes::install_github("https://github.com/open-AIMS/gisaimsr")

#cleanup
rm(package_list, new_packages)

```

```{r}
#| label: load packages
#| output: false
#| echo: false

#graphing and mapping
library(RColorBrewer) #colour palettes, and create custom palettes
library(sf) #read and manipulate simple features
library(tmap) #map data
library(osmdata) #online data repo from open street map
library(gifski) #easy interactive visualisations

#general setup and data manipulation
library(glue) #easier to create strings, particularly those contains variables
library(lubridate) #time manipulation
library(terra) #spatial raster manipulation
library(tidyverse) #contains multiple useful packages (https://www.tidyverse.org/packages/)
library(stringr) #additional help on string manipulation
library(dataaimsr) #load the aims datasets

```

```{r}
#| label: global vars and initial setup
#| output: false

#set project variables: crs factor and current_fyear
proj_crs <- params$project_crs

#format the date for the path below and to be used as a variable in naming later
date <- format(Sys.time(), "%Y-%m-%d")

#create a file path to help with saving things
save_path <- glue("output/{date}_n3-basin-builder/")

#bring that path to life
dir.create(save_path)

#initilize with static mapping
tmap_mode("plot")

#turn off spherical geometry
sf_use_s2(F)

```

Our project coordinate reference system (CRS) that we use to interpret all geographic data is set to `r proj_crs`.

# Data Source

Load in the relevant shapefiles. If this is the first time running the analysis and/or the shapefiles are not in the folder, please refer to the .README for this repo for a guide on downloading the data.

```{r}
#| label: load in the relevant shapefiles
#| output: false

#Import the Environmental Protection Policy env value zones layer
EPP_water_env_value <- st_read(dsn = "data/shapefiles", 
                               layer = "EPP_Water_Env_Value_Zones_Cropped")

#Import the Environmental Protection Policy water types layer
EPP_water_types <- st_read(dsn = "data/shapefiles",
                           layer = "EPP_Water_water_types_Cropped")

#read in waterbodies data from the gisaimsr package
data("wbodies", package = "gisaimsr")

#read in the basins used by nrms and gbrmpa
basins <- st_read(dsn = "data/shapefiles/Drainage_basins.shp")

#update crs
EPP_water_env_value <- st_transform(EPP_water_env_value, proj_crs)
EPP_water_types <- st_transform(EPP_water_types, proj_crs)
wbodies <- st_transform(wbodies, proj_crs)
basins <- st_transform(basins, proj_crs)

```

# Creation of Sub-basins

In the Dry Tropics region there are only two official basins: The Ross Basin, and The Black Basin. However each of these basins contain multiple unique environments that are not best represented collectively. For example the Black Basin is wide and narrow (relative to the coastline) and consists of more than a dozen individual river systems. Below we divide the basins into sections based on boundaries used by the EPP environmental value dataset and the major rivers within.

```{r}
#| label: divide the Ross and Black Basins

#select relevant features (land only)
tsv_wev_temp <- EPP_water_env_value %>% 
  filter(PROJECT_NA == "Townsville Region" & ENV_VALUE_ != "Halifax & Cleveland Bay")

#save a before plot for below
map1 <- tsv_wev_temp

#create a list of groups that will be used
group_list <- c("Two|Christmas", "Deep Creek|Althaus|Healy", "Alick|Black R|Log C|Canal|Alice",
                "Town C|Pall", "Middle B|(lower)", "Round|Plum|Six|One|Toon",
                "Anthill|Slippery|Alligator|Killymoon|Crocodile|Cape",
                "below dam|Mt Stuart|Sachs", "Stuart C|State|Sandfly|Whites",
                "Bay|Retreat|China|Duck|Ned|Butlers|Gustav|Petersen|Magnetic|Gorge|Endeavour")

#assign a value based on what group each polygon should be in, some are their own group
tsv_wev_temp <- tsv_wev_temp %>%
  mutate(zone = BASIN_NAME,
    grouping_var = case_when(str_detect(ENV_VALUE_, group_list[1]) ~ nrow(tsv_wev_temp) + 1,
                             str_detect(ENV_VALUE_, group_list[2]) ~ nrow(tsv_wev_temp) + 2,
                             str_detect(ENV_VALUE_, group_list[3]) ~ nrow(tsv_wev_temp) + 3,
                             str_detect(ENV_VALUE_, group_list[4]) ~ nrow(tsv_wev_temp) + 4,
                             str_detect(ENV_VALUE_, group_list[5]) ~ nrow(tsv_wev_temp) + 5,
                             str_detect(ENV_VALUE_, group_list[6]) ~ nrow(tsv_wev_temp) + 6,
                             str_detect(ENV_VALUE_, group_list[7]) ~ nrow(tsv_wev_temp) + 7,
                             str_detect(ENV_VALUE_, group_list[8]) ~ nrow(tsv_wev_temp) + 8,
                             str_detect(ENV_VALUE_, group_list[9]) ~ nrow(tsv_wev_temp) + 9,
                             str_detect(ENV_VALUE_, group_list[10]) ~ nrow(tsv_wev_temp) + 10), .after = ENV_VALUE_) %>%
  mutate(rowid_to_column(tsv_wev_temp, "ID"),
         grouping_var = coalesce(grouping_var, ID)) %>% 
  select(-SCHEDULE, -BASIN_NUMB, -ID)

#combine names based on grouping and edit zone
tsv_wev_temp <- tsv_wev_temp %>% 
  group_by(grouping_var) %>% 
  mutate(contains = paste0(ENV_VALUE_, collapse = ", ")) %>% 
  group_by(contains, zone) %>% 
  summarise() %>% 
  mutate(zone = case_when(str_detect(zone, "Black") ~ "black",
                          str_detect(zone, "Ross") ~ "ross"))

#create list of names that will be used for each group
sub_zone <- c("Black River", "Althaus Creek", "Bluewater Creek", "Bohle River (upper)", "Camp Oven Creek",
              "Alligator Creek", "Sleeper Log Creek", "Crystal Creek", "Ross River Dam", "Leichhardt Creek",
              "Ollera Creek", "Louisa Creek", "Ross River (lower)", "Magnetic Island", "Town Common", 
              "Rollingstone Creek", "Ross Creek", "Saltwater Creek", "Station Creek", "Bohle River (lower)", "Stuart Creek",
              "Surveryors Creek", "Ross River (upper)")
 
#bind the names to the sf data
tsv_wev <- cbind(tsv_wev_temp, sub_zone)

#cleanup
rm(group_list, sub_zone, tsv_wev_temp)

```

This is before:

```{r}
#| label: visualise before

plot(map1["ENV_VALUE_"])

#cleanup
rm(map1)

```

And this is after (ignoring the legend - not sure why that happens):

```{r}
#| label: visualise after

plot(tsv_wev["sub_zone"])

```

# Creation of Freshwater and Estuarine areas

The report card seperates its land-based water features into fresh and estuarine systems. Once again the EPP datasets provide the necessary divisions. This time we will be using the Water Types data. The code below adds these divisions.

```{r}
#| label: prep the fresh and estuarine polygons

#select townsville region, get the fresh and estuarine components and combine into one polygon
tsv_fre <- EPP_water_types %>% 
  filter(PROJECT_NA %in% c("Townsville Region"),
         !str_detect(WATER_TYPE, "coast|estua")) %>% 
  st_union(by_feature = FALSE) %>%
  st_combine() %>% nngeo::st_remove_holes() %>% st_sf()

tsv_est <- EPP_water_types %>% 
  filter(PROJECT_NA %in% c("Townsville Region"),
         str_detect(WATER_TYPE, "estua")) %>% 
  st_union(by_feature = FALSE) %>%
  st_combine() %>% nngeo::st_remove_holes() %>% st_sf()

#combine the fresh, estuarine and wev polygons
temp1 <- st_intersection(tsv_wev, tsv_fre) %>% 
  mutate(env = "fresh") %>% 
  group_by(sub_zone, zone, env) %>% 
  st_collection_extract("POLYGON") %>% 
  summarise(geometry = st_union(geometry))

temp2 <- st_intersection(tsv_wev, tsv_est) %>% 
  mutate(env = "estuarine") %>% 
  group_by(sub_zone, zone, env) %>% 
  st_collection_extract("POLYGON") %>% 
  summarise(geometry = st_union(geometry))

#join everything back together
tsv_wev_wt <- rbind(temp1, temp2)

#clean up
rm(tsv_fre, tsv_est, temp1, temp2)

```

Before is the plot above, and here is after:

```{r}
#| label: visualise after3

plot(tsv_wev_wt["env"])

```

# Creation of Marine areas

Next we need to build the marine divisions for the Dry Tropics region. These divisions are based on the GBRMPA dataset provided within the aims package and therefore the data is not visible within the shapefile folder. Refer to the .README for more information if required. The code chunk below introduces these divisions.

First we need to create a rough outline of our marine area:

```{r}
#| label: rough marine outline

#raw numbers for the Black/Halifax bay coastal boundary and Ross/Cleveland bay coastal boundary. 
#Note that this is a hand drawn boundary - no online backup. Note the first and last lat and long 
#coordinates match to close the polygon
lon_h <- c(147.3247, 146.6656, 146.6656, 146.2960, 146.2960, 146.4415, 146.4429, 
           146.9999, 147.3247)
lat_h <- c(-17.6958, -19.2108, -19.3867, -18.9512, -18.8976, -18.8976, -18.3898,
           -17.4958, -17.6958) 
#ross/cleveland
lon_c <- c(146.6656, 147.3247, 148.0303, 147.6438, 147.0198, 147.0293, 147.0057, 
           147.0057, 146.6656, 146.6656)
lat_c <- c(-19.2108, -17.6958, -18.1305, -18.7596, -19.1927, -19.2088, -19.3004, 
           -19.3867, -19.3867, -19.2108)

#concatenate long and lat, make it a matrix, create a polygon by providing the matrix as a list, 
#turn polygon into a simple feature class
halifax_bay <- st_sfc(st_polygon(list(matrix(c(lon_h, lat_h),,2))))
cleveland_bay <- st_sfc(st_polygon(list(matrix(c(lon_c, lat_c),,2))))

#combine these together
dt_marine_rough <- st_sf(c(halifax_bay, cleveland_bay), crs = proj_crs) %>% 
  rename(geometry = 1) %>% 
  mutate(zone = c("Halifax Bay", "Cleveland Bay"),
         MarineWate = "Enclosed Coastal", .before = "geometry")

#cleanup
rm(lon_h, lat_h, lon_c, lat_c, halifax_bay, cleveland_bay)

#visualise
plot(dt_marine_rough["zone"])

```

Then we need to overlay the marine divisions that fall within our rough outline and group up all the geometries that share the same properties. We also need to combine the offshore marine zone into one polygon.

```{r}
#| label: overlay marine divisions

#get x within y
intersection <- st_intersection(wbodies, dt_marine_rough) |> select(MarineWate, zone)

#bind the intersection back over the top of the rough outline, then group and union geometry
marine <- rbind(dt_marine_rough, intersection) |> 
  group_by(zone, MarineWate) |> summarise(geometry = st_union(geometry)) |> 
  rename(sub_zone = MarineWate)

#merge offshore zone and union again
marine <- marine |> mutate(zone = case_when(sub_zone == "Offshore" ~ "Offshore",
                                            TRUE ~ zone)) |> 
  group_by(zone, sub_zone) |> summarise(geometry = st_union(geometry)) |> mutate(env = "marine")

#cleanup
rm(dt_marine_rough, intersection)

#visualise
plot(marine)

```

# Combining Land and Marine areas

As the land and marine shapefiles were developed separately, they need to be combined. The below code chunk does this combination.

```{r}
#| label: combine land and marine areas

#get just the polygon outline of the land
blank <- tsv_wev_wt %>% st_union(by_feature = FALSE) %>%
  st_combine() %>% nngeo::st_remove_holes() %>% st_sf()

#cut the marine shapefile by land
marine <- st_difference(marine, blank)

#join everything together
tsv_wev_wt_wb <- rbind(tsv_wev_wt, marine)

#visualise
plot(tsv_wev_wt_wb)

```

# Adressing inconsistencies

The painful part of this process is that these divisions were created based on DES mapping requirements. Therefore the Black and Ross Basin outlines are slightly different from the Black and Ross Basin outlines used by the more widely accepted Drainage_basins shapefiles. The below code rectifies the biggest disparity between the basin outlines (the Alligator Ck/Cape Cleveland corner of the Ross Basin).

```{r}
#| label: rectify the difference between the two Ross basin outlines

#select the Ross and Black Basins
tsv_basin <- basins |> 
  filter(BASIN_NAME %in% c("Ross", "Black"))

#union the main shapefile for the difference function
temp <- tsv_wev_wt_wb |> st_union()

#take the difference of the two outlines and cast the multipolygon to polygons
temp <- st_cast(st_difference(tsv_basin, temp), "POLYGON")

#calculate the area of each polygon and select only the biggest
temp$area <- st_area(temp)

#select only the biggest one
temp <- temp|> slice_max(area, n = 1)

#edit for the rbind function
temp <- temp |> select(geometry) |> mutate(env = "fresh", zone = "ross",
                                           sub_zone = "Alligator Creek", .before = geometry)

#bind the temp polygon back onto the main
tsv_wev_wt_wb <- rbind(tsv_wev_wt_wb, temp)

#combine names based on grouping
tsv_wev_wt_wb <- tsv_wev_wt_wb |> group_by(sub_zone, zone, env) |> summarise()

#extract only polygons
tsv_wev_wt_wb <- st_collection_extract(tsv_wev_wt_wb, type = "POLYGON")

#cleanup
rm(temp)

#save the file
st_write(tsv_wev_wt_wb, dsn = "data/shapefiles/Dry-Tropics-Basins-Detailed.shp",
         delete_layer = T)

```

Before is the plot above, and here is after (note the right corner of the Ross Basin):

```{r}
#| label: visualise after2

plot(tsv_wev_wt_wb["sub_zone"])

```
